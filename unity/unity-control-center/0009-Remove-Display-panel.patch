From d39d5964668d3872996cf7df5226ce57fb881892 Mon Sep 17 00:00:00 2001
From: Xiao-Long Chen <chenxiaolong@cxl.epac.to>
Date: Sat, 5 Apr 2014 19:45:29 -0400
Subject: [PATCH 09/19] Remove Display panel

---
 configure.ac                                       |    3 -
 man/unity-control-center.xml                       |   11 -
 panels/Makefile.am                                 |    1 -
 panels/display/Makefile.am                         |   71 -
 panels/display/TODO                                |  837 -----
 panels/display/cc-display-panel.c                  | 3256 --------------------
 panels/display/cc-display-panel.h                  |   74 -
 panels/display/cc-rr-labeler.c                     |  601 ----
 panels/display/cc-rr-labeler.h                     |   64 -
 panels/display/display-capplet.ui                  |  566 ----
 panels/display/display-module.c                    |   41 -
 panels/display/foo-marshal.list                    |    6 -
 panels/display/icons/24x24/unity-display-panel.svg |   55 -
 panels/display/icons/48x48/unity-display-panel.svg |   70 -
 panels/display/scrollarea.c                        | 1573 ----------
 panels/display/scrollarea.h                        |  127 -
 panels/display/unity-display-panel.desktop.in.in   |   13 -
 po/POTFILES.in                                     |    4 -
 po/POTFILES.skip                                   |    1 -
 19 files changed, 7374 deletions(-)
 delete mode 100644 panels/display/Makefile.am
 delete mode 100644 panels/display/TODO
 delete mode 100644 panels/display/cc-display-panel.c
 delete mode 100644 panels/display/cc-display-panel.h
 delete mode 100644 panels/display/cc-rr-labeler.c
 delete mode 100644 panels/display/cc-rr-labeler.h
 delete mode 100644 panels/display/display-capplet.ui
 delete mode 100644 panels/display/display-module.c
 delete mode 100644 panels/display/foo-marshal.list
 delete mode 100644 panels/display/icons/24x24/unity-display-panel.svg
 delete mode 100644 panels/display/icons/48x48/unity-display-panel.svg
 delete mode 100644 panels/display/scrollarea.c
 delete mode 100644 panels/display/scrollarea.h
 delete mode 100644 panels/display/unity-display-panel.desktop.in.in

diff --git a/configure.ac b/configure.ac
index 334b36c..1160053 100644
--- a/configure.ac
+++ b/configure.ac
@@ -119,7 +119,6 @@ PKG_CHECK_MODULES(APPEARANCE_PANEL, $COMMON_MODULES libxml-2.0 gnome-desktop-3.0
                   gdk-pixbuf-2.0 >= $GDKPIXBUF_REQUIRED_VERSION)
 PKG_CHECK_MODULES(DATETIME_PANEL, $COMMON_MODULES timezonemap
                   polkit-gobject-1 >= $POLKIT_REQUIRED_VERSION)
-PKG_CHECK_MODULES(DISPLAY_PANEL, $COMMON_MODULES gnome-desktop-3.0 >= 3.1.0 x11)
 PKG_CHECK_MODULES(INFO_PANEL, $COMMON_MODULES libgtop-2.0 gl x11
 		  polkit-gobject-1 >= $POLKIT_REQUIRED_VERSION webkitgtk-3.0)
 PKG_CHECK_MODULES(MEDIA_PANEL, $COMMON_MODULES)
@@ -316,8 +315,6 @@ panels/appearance/Makefile
 panels/appearance/unity-appearance-panel.desktop.in
 panels/datetime/Makefile
 panels/datetime/unity-datetime-panel.desktop.in
-panels/display/Makefile
-panels/display/unity-display-panel.desktop.in
 panels/mouse/Makefile
 panels/mouse/unity-mouse-panel.desktop.in
 panels/sound/Makefile
diff --git a/man/unity-control-center.xml b/man/unity-control-center.xml
index 1ab9f4a..f3c6247 100644
--- a/man/unity-control-center.xml
+++ b/man/unity-control-center.xml
@@ -87,17 +87,6 @@
                         </varlistentry>
 
                         <varlistentry>
-                                <term><option>display</option></term>
-
-                                <listitem><para>The display panel configures
-                                the resolution and arrangement of monitors
-                                and laptop panels. Note that monitors can be
-                                rearranged by drag-and-drop, and you can change
-                                which monitor is your main display by dragging
-                                the black bar.</para></listitem>
-                        </varlistentry>
-
-                        <varlistentry>
                                 <term><option>info</option></term>
 
                                 <listitem><para>The info panel shows a general
diff --git a/panels/Makefile.am b/panels/Makefile.am
index a2fd731..32555e4 100644
--- a/panels/Makefile.am
+++ b/panels/Makefile.am
@@ -3,7 +3,6 @@ SUBDIRS= \
 	common \
 	datetime \
 	screen \
-	display \
 	mouse \
 	info \
 	sound \
diff --git a/panels/display/Makefile.am b/panels/display/Makefile.am
deleted file mode 100644
index 12dbb1a..0000000
--- a/panels/display/Makefile.am
+++ /dev/null
@@ -1,71 +0,0 @@
-# This is used in PANEL_CFLAGS
-cappletname = display
-
-uidir = $(pkgdatadir)/ui
-dist_ui_DATA = display-capplet.ui
-
-MARSHALFILES = foo-marshal.c foo-marshal.h
-BUILT_SOURCES = $(MARSHALFILES)
-
-foo-marshal.c: foo-marshal.h
-	$(AM_V_GEN) ( $(GLIB_GENMARSHAL) --prefix=foo_marshal $(srcdir)/foo-marshal.list --header --body > foo-marshal.c )
-foo-marshal.h: foo-marshal.list
-	$(AM_V_GEN) ( $(GLIB_GENMARSHAL) --prefix=foo_marshal $(srcdir)/foo-marshal.list --header > foo-marshal.h )
-
-ccpanelsdir = $(PANELS_DIR)
-ccpanels_LTLIBRARIES = libdisplay.la
-
-libdisplay_la_SOURCES =		\
-	display-module.c	\
-	cc-display-panel.c	\
-	cc-display-panel.h	\
-	cc-rr-labeler.c		\
-	cc-rr-labeler.h		\
-	scrollarea.c		\
-	scrollarea.h		\
-	$(MARSHALFILES)
-
-libdisplay_la_LIBADD = $(PANEL_LIBS) $(DISPLAY_PANEL_LIBS)
-libdisplay_la_LDFLAGS = $(PANEL_LDFLAGS)
-
-# You will need a recent intltool or the patch from this bug
-# http://bugzilla.gnome.org/show_bug.cgi?id=462312
-@INTLTOOL_POLICY_RULE@
-
-@INTLTOOL_DESKTOP_RULE@
-
-icons24dir = $(datadir)/icons/hicolor/24x24/apps
-dist_icons24_DATA = icons/24x24/unity-display-panel.svg
-icons48dir = $(datadir)/icons/hicolor/48x48/apps
-dist_icons48_DATA = icons/48x48/unity-display-panel.svg
-
-desktopdir = $(datadir)/applications
-Desktop_in_files = unity-display-panel.desktop.in
-desktop_DATA = $(Desktop_in_files:.desktop.in=.desktop)
-
-INCLUDES   = $(PANEL_CFLAGS) \
-	     $(DISPLAY_PANEL_CFLAGS) \
-	     -DSBINDIR="\"$(sbindir)\"" \
-	     -DUIDIR="\"$(uidir)\"" \
-	     -DGNOMELOCALEDIR="\"$(datadir)/locale\"" \
-	     -DGNOMECC_DATA_DIR="\"$(pkgdatadir)\""
-
-CLEANFILES = $(Desktop_in_files) $(desktop_DATA)
-
-if MAINTAINER_MODE
-gtk_update_icon_cache = gtk-update-icon-cache -f -t $(datadir)/icons/hicolor
-install-data-hook: update-icon-cache
-uninstall-hook: update-icon-cache
-update-icon-cache:
-	@-if test -z "$(DESTDIR)"; then \
-		echo "Updating Gtk icon cache."; \
-		$(gtk_update_icon_cache); \
-	else \
-		echo "*** Icon cache not updated.  After (un)install, run this:"; \
-		echo "***   $(gtk_update_icon_cache)"; \
-	fi
-endif
-
-EXTRA_DIST = foo-marshal.list
-
--include $(top_srcdir)/git.mk
diff --git a/panels/display/TODO b/panels/display/TODO
deleted file mode 100644
index f09425c..0000000
--- a/panels/display/TODO
+++ /dev/null
@@ -1,837 +0,0 @@
-Highlevel overview:
-
-Tablet rotation things
-only when there is a tablet attached.
-
-Here is the OS X Display menu:
-
-	Detect Displays
-	Turn on mirroring
-	--------------------------
-	SyncMaster
-		- 1280 x 1024, 60 Hz, Millions
-	        - 1344 x ...
-	--------------------------------
-	Color LCD
-		- 1024 x 1024 ...
-	--------------------------
-	Displays Preferences
-	
-	Color LCD means "laptop panel".
-
-- GTK+ work.
-
-	Allow applications to be notified whenever monitors are added
-	or removed. Allow applications to get more detailed
-	information about the connected monitors.
-
-	The main complication is that XRRGetScreenResources() is very 
-	slow. We could call it only when the X server sends an event,
-        but it's not desirable to have every application freeze for
-        half a second. And certainly not desirable to have the X
-        server block for n * 0.5 seconds.
-
-	With the X server work below we should be fine just calling
-        XRRGetScreenResources on startup and in response to events.
-
-- X server work:
-
-	X server needs to poll for whether a monitor is plugged
-        in. Whenever it detects a change, it should do an EDID query,
-        and cache the resulting information. That way XRRGetScreenResources()
-	can be the speed of a normal roundtrip. It's desirable that 
-	normal client requests can still be processed during the EDID
-        querying, but only a nice-to-have.
-
-	Drivers need to work reliably. There could be substantial work
-	here. For F9, possibly only the Intel driver can be made to
-	work. 
-
-	Interrupts and events must be generated whenever something changes
-	about the outputs, if necessary by polling.
-
-	Events must be emitted whenever something changes, including when
-	the reason for the change is a manual change.
-
-	The maximum framebuffer must be dynamically changable.
-
-- Control panel work:
-	Capplet needs to be written. The main complications:
-
-	- It needs to pay attention to events from the X server
-	  and update itself, ie., add show new monitors if they become
-	  available when the applet is shown.
-
-	- It needs to store information under a key computed 
-	  from a monitor identifier. The complication here is that
-          it's not completely clear how to do this in GConf.
-
-	- Would probably be worthwhile to drop libgnome/libgnomeui from
-	  the craplets.
-
-- Metacity work:
-	- Metacity is already Xinerama aware, but it needs to update itself
-	  when monitors come and go. 
-
-- GNOME panel work:
-	- Is already Xinerama aware, but needs to listen and update itself
-	  when monitors change. 
-
-- Evince work:
-	- Make sure it deals sensibly with multiple monitors
-
-- OpenOffice work:
-	- Make sure it deals sensibly with multiple monitors
-
-- An Xlib call to just return all the available information would be
-  useful. At the moment we have to do a bunch of roundtrips to
-  get the information. This is a would-be-nice though.
-
-- A dbus service could be written that pops up the applet whenever a
-  monitor. It should only pop up if the new monitor is unknown. This
-  is at best a nice-to-have, and low priority in my opinion.
-
-
-*******************  Metacity
-
-Havoc:
-
-> I was just talking to bryan about this and "helping" him design it ;-)
-
-> But I wanted to be sure and lobby for a fix window managers
-> need. Basically right now the WM can't tell "physical" from
-> "logical" monitors.
-
-> A "logical" monitor is a desktop; it has its own panel, windows
-> maximize to it, etc.
-
-> A "physical" monitor is a piece of hardware.
-
-> Sometimes people want to combine physical monitors into a video wall
-> or just two monitors treated as one. Or at least a couple of noisy
-> people in bugzilla want to do this.
-
-> When people talk about a "Xinerama aware" app or WM they usually
-> mean that all physical monitors are treated as logical monitors,
-> while lack of Xinerama-aware means treating the entire X screen (all
-> physical monitors) as one logical monitor.
-
-> The problem is that the setting for "ignore Xinerama" or "don't be
-> Xinerama aware" should be global to the desktop (GTK, all apps, WM)
-> and should not be a window manager setting.
-
-> Bryan thought people who wanted non-Xinerama-aware should just use
-> fvwm, which may be right, but what I'd say is that if there is any
-> setting for this, it should be desktop-global and in this monitor
-> config dialog.
-
-> It should not be a metacity or Compiz option, but in some way an X
-> option in short. The implementation could be either an X server
-> feature or an EWMH hint or whatever, but it should be controlled by
-> the monitor config dialog and used by apps, GTK, etc. in addition to
-> used by the WM.
-
-> People tend to insist this should be a WM option, but that's just
-> busted, since GTK and apps also have Xinerama-awareness features.
-
-
-******************* EDID
-
-edid-decode enhancements:
-
-- Rejects years <= 0x0f for all versions, but this should only be done
-  for monitors claiming conformance to 1.4 (since 1.4 was released in
-  2006). A monitor produced in 2005 should have 0x0f - it's the only 
-  reasonable thing to do.
-
-- Uses 0x80 as the conformance mask for 1.4, should be 0
-
-- Should read from stdin
-
-- Should parse xrandr -verbose output more robustly
-
-- Color depth computation is wrong. It uses the formula
-
-	(edid[0x14] >> 3) + 2
-
-  The correct formula to use is
-
-	(edid[0x14] & 0x70) >> 3 + 4
-
-- 
-
--=-=-=-
-Computing a display name from EDID information:
-
-	  vendor = lookup_vendor (code);
-
-	  if (dsc_product && !is_gobbledigook (dsc_product))
-	  {
-               if (vendor && !fuzzy_string_search (vendor, dsc_product))
-	       	  prepend (vendor);
-	  }
-	  else
-	  {
-		if (vendor)
-		   append (vendor);
-		else
-		   append ("Unknown");
-	  }
-
-          if (has size)
-	  {
-		convert_to_inches()
-
-		append (" %d\"", inches)
-	  }
-
-(Does this internationalize at all)?
-
-We also need the ability to get laptop names. The laptop panel may report
-a manufacturer that has nothing to do with the laptop manufacturer.
-
-Needed XRandr output properties:
-
-- Modes that the monitor supports, or enough information that the
-  client can go throught the list of modes for the relevant
-  CRTC/Outputs and filter those out that the monitor can't support.
-
-- The preferred mode, if any. Also useful if we could get a "strongly
-  preferred" indication if it's an LCD with a fixed resolution.
-
-- Sufficient information that a fairly specific identifier can be
-  computed. The algorithm the client should use is:
-
-	1 Have we seen exactly this monitor before? If yes, use
-          settings for that.
-
-	2 Have we seen a monitor with similar specs before? If yes,
-	  use settings for that. (But don't save, unless the user
-	  changes the settings).
-
-	3 Otherwise, use some reasonable default for the monitor and
-          save it.
-
-  A setting should only be used if the CRTC/Output allows it. Ie,. if
-  a user has installed a new video card, then previously-used settings
-  may no longer apply, so this must be checked every time.
-
-  (1) Implies that we really need a globally unique identifier for
-  monitors. (2) is useful in an enterprise setting, but not absolutely
-  critical, since (3) would still handle the majority of cases.
-
-  There is a question here: Where are machine specific preferences
-  stored? Havoc mentions three possibilities here:
-
-     http://mail.gnome.org/archives/gnomecc-list/2001-October/msg00023.html
-
-  I'm not sure if any of them are implementable at this point. Also
-  (1) may mostly take care of the problem.
-
-
-  Usecases:
-
-  1. Fixed setup with some number of monitors.
-     - They should be set to the correct mode on login. 
-       Note that this involves setting the right position in the
-       framebuffer too.
-
-       What if someone swaps two monitors? Users are going to expect
-       that the images will switch position.
-
-  2. Laptop being moved between home and work
-     - Setups should be detected and the correct mode set, at least on
-       login, but ideally when you put the laptop into the docking
-       station.
-
-  3. Laptop gets projector plugged in.
-
-  Note the same model monitor can be used in two different ways. Ie.,
-  at home, it's being used at one resolution, at work the same type of
-  monitor is used at a different resolution.
-
-  Simple solution:
-
-  - The on-disk database is just a list of monitors. Each monitor has an
-    associated mode. This has these problems:
-         - If someone uses the same monitor model in two different ways.
-         - If someone swaps the monitors around
-
-  Better solution
-
-  - The on-disk database is a list of configurations, where a
-    configuration is a list of monitors and what outputs they are
-    connected to, and the position in the framebuffer.
-
-  - Picking a default configuration is then a matter of selecting the
-    closest existing configuration from the database.
-
-    	- If the stored configuration is a subset of the existing, 
-	  then use that - then pick the best mode available for the
-	  rest of the monitors
-
-	- If the stored configuration is a superset of the existing,
-	  then use the projection of the configuration onto the monitors.
-
-	- Pick the configuration with the most overlap in monitors.
-	  Although, if a configuration differs only in what outputs
-	  they are connected to, then those outputs should probably
-	  get their original modes set.
-
-  - Or maybe simply:
-
-    - If there is an exact match, use it, if not, pick a default.
-    
-    - Picking a new default must never change the mode of any existing
-      output.
-
-******************* Capplet
-
-Somehow the applet will find out that a new monitor is plugged in
-(either through notification, or through a refresh button). When this
-happens, this monitor is looked up in a database and if it is found,
-some suitable mode is set.
-
-Restrictions on the modes:
-
-- Monitors that are already plugged in should not get their mode
-  changed just because a new monitor is plugged in.
-
-- If the exact configuration of monitors is known, and all the old
-  monitors have the same mode as the known configuration, then just use
-  the known configuration. Also do this, if the configuration is a
-  subset of something known.
-
-- Otherwise, if the configuration is a subset of a known configuration
-  where the only difference is that existing monitors have different
-  modes, then try and convert that mode to something we can know
-  about. Maybe configurations should be stored in terms of edges that
-  line up.
-
-- Otherwise, just pick some good default for the mode, probably based
-  on the EDID prferred mode if possible. By default cloning is
-  probably best.
-
-- How do virtual desktops interact with this?
-
-
-g-s-d:
-
-- On startup 
-
-     - It reads the configuration file into memory
-
-       	    capplet --configure
-
-     - It gathers the existing configuration from randr
-
-     - If the existing config is in the file, set that mode
-
-- On changes, including changes to the config file [this is crack]
-
-     - Reread configuration file
-
-     - Compare new configuration to database, if it is there, set the
-       mode as appropriate
-
-     - If a monitor was added, pop up a bubble
-
-       	    capplet --show-bubble
-
-       	    capplet --set-mode
-
-capplet
-
-- On changes
-
-     - Update GUI
-
-- When user changes something, 
-
-     - Write configuration to file
-
-     - Signal gsd somehow
-
-Schemes:
-	- configuration file changes
-	  - randr code will have to be shared between gcc and gsd
-
-	- binary installed by gcc
-	  - something will still have to listen for changes to pop
-	    up the notification bubble.
-
-Structure of capplet:
-
-- There is a database on disk with monitors and their corresponding
-  settings.
-
-- On startup, this database is read into memory. When the user accepts
-  new settings, it is written back to disk.
-
-- When something changes about the settings
-
-  - If new configuration is in the database, use that mode
-
-  - Else, find all outputs that are now connected but weren't before,
-    and set a default mode for them.
-
-  - If GUI is running, update graphics.
-
-
-  - Notification thing: 
-      - if 
-
-      - if the new configuration is found in the database, use it
-
-  and added if they are not already there. Initial settings are
-      1 what the output is already doing, if anything
-      2 based on an existing sufficiently similar monitor, if possible
-      3 some reasonable default.
-
-- When the user changes settings in the GUI, the corresponding monitor
-  in the database is updated.
-
-- Whenever the GUI settings change, for all displayed monitors the
-  possible modes are recomputed.
-
-- Whenever a new monitor is selected in the GUI, it first gets all its
-  possible modes computed based on the selections on other
-  outputs. Then, if the possible modes include the existing choice of
-  resolution, that is selected.
-
-  Actually, 
-
-  - initially, the settings are copied from the current settings
-
-  - whenever a gui setting changes for a monitor, all the other
-    monitors get their list of choices set to whatever is possible
-    given the chocie for the current monitor. A 'desired mode' is
-    maintained, and the closest choice to that is displayed. Whenever
-    the user actively selects something, that becomes the desired mode
-    for that monitor.
-
-- Required
-
-  - Generate all outputs that are newly connected
-
-    	     foreach_newly_connected (Configuration *before, Configuration *after, 
-	     			      OutputFunc);
-
-  - A way to generate the best mode for a connected output
-
-      	     existing best_mode() can probably be used
-
-  - Given a list of modes, pick the one closest to a given mode. 
-
-      	     (a possibility here is: pick an exact match, if that's
-	      impossible, then pick the best one with the same
-	      width/height, if that's impossible, then just pick the
-	      best mode on the list).
-
-  - For a configuation, fix the mode for a subset of the outputs, then
-    list the combinations for the rest of the outputs.
-
-    	     An obvious possibility here is to simply list all possibilities, 
-	     then  weed out those that don't work. Is this too expensive? 
-	     It might be.
-
-Structure of login time program:
-
-- The configuration database is read
-
-- The current hardware configuration is generated
-
-- If the current configuration is found in the database, that mode is set.
-
-- If it isn't found, then nothing changes.
-
-     This could just be gnome-screen-resolution-capplet --reset
-
-*******************  Things that need to be done to the xrandr.patch:
-
-===
-
-XRRGetScreenResources() is a roundtrip and very slow (~0.5 s). GTK+
-needs to keep information up-to-date by tracking events rather than
-calling this function. In fact we probably can't call it at all unless
-its performance improves significantly.
-
-If EDID processing really has to be this slow, and we can't get
-interrupts when monitors are plugged in, then we have a problem,
-because we can't do anything this expensive once per second.
-
-
-Detailed notes (but most of the patch should be rewritten):
-
-
-=== FIXME in gdkscreen-x11.c in get_width_mm()
-
-/* monitor pixel width / screen pixel width * screen_physical width */
-
-
-
-=== Check for 1.2 library
-
-The patch should check that the 1.2 version of the XRandR library is
-available before using the functions. A possibility is to not use any
-RandR unless 1.2 is available, another is to conditionalize the code.
-
-The most sane thing is probably to just require 1.2.
-
-On the other hand, installing a newer gtk+ on a system with older X is
-probably not that unusual, so maybe it's better to do the full 1.0,
-vs. 1.1 vs 1.2 check.
-
-For now it just requires 1.2.
-
-Actually, this might be fine because the only place where we make use
-of a 1.1 library is in the _gdk_x11_screen_size_changed() function,
-but there we have a fallback that just updates the variables in the
-Screen struct itself.
-
-So, only defining HAVE_RANDR if we detect 1.2 should be ok.
-
-=== Monitor information available
-
-- Subpixel information. This should be set automatically for the fonts and
-  store under the name of the monitor. If the user changes the font
-  configuration, that change should also be stored under the monitor name.
-
-- When a monitor we don't know about is plugged in, a configuration should
-  be generated:
-
-	- Screen size, computed based on the location of the screens 
-
-	- RGBA information
-
-	- Whether the screen has a panel on it
-
-	- If there is a conflict between stored information and EDID,
-          the stored information wins
-
-	
-
-New API so far:
-
-(* monitors_changed) signal
-gdk_screen_get_monitor_width_mm()
-gdk_screen_get_monitor_height_mm()
-gdk_screen_get_monitor_name() => Note this is the output (eg. "DVI-0")
-
-We should probably also have 
-get_manufacturer()
-get_serial()
-get_resolutions()
-
-etc. 
-
-Should there be a GdkMonitor object that would correspond to an
-output? Or maybe GdkOutput?
-
-screen_list_monitors()
-
-
-*************************** Issues XRandR/Xserver
-
-- We need polling in the X server, whenever something changes, X must
-  recompute the information and cache it, then send an event. Note the
-  situation where the user disconnects and reconnects a monitor within
-  the polling interval. The event could missed in that case since the polling
-  cannot do a full EDID query. Difficult to see a way around this.
-
-  Actually, DDC allows random access, so it should be possible to just
-  read theq vendor id and manufacturer codes. This can be done once a
-  second without a problem. The polling should be turned off in power
-  saving mode anyway.
-
-  - Driver work:
-
-  - Intel driver:
-
-    - EDID information is not reported for VGA when the output is not 
-      turned on (i945 laptop).
-
-    - Screen size must be dynamically changable. (No xorg.conf changes
-      should be required).
-
-    - Make use of ACPI information when possible. 
-
-      Adam has code on his freedesktop page.
-
-    - i830 laptop can be put in a state where XRandr reports that no
-      outputs are connected to a CRTC, but the panel is on.
-
-      	      - Plug in VGA
-	      - xrandr --auto
-	      - xrandr --output VGA --off
-	      - run chk 
-	      - xrandr --verbose will now not report any outputs as turned on
-	      - run chk again - all screens will be turned off
-
-    - Small Sun monitor - an 1152x921 mode is generated, but the
-      monitor doesn't handle that. The monitor itself only claims to
-      handle 1152x920.  It doesn't look to me like there is anything
-      in the EDID information that would indicate that it could handle
-      1152x921.
-
-      This happens with a radeon as wellso it may be a bug in the
-      generic X server EDID parsing. The X server apparently
-      interpretes the standard timing 1152x920 as 1152x921.
-
-      This happens because the X server uses
-
-      	    hsize * 4 / 5
-
-      which gives 921 for 1152. By using
-
-      	    (hsize / 5) * 4
-
-      you get 920. The 66 Hz version can bet set, the 76 Hz mode gets
-      sync out of range. (Would be interesting to find out whether the
-      1152x920 ModeLine would allow the 76 Hz version to be set).
-
-  This is for the ATI driver as shipped in F8:
-
-  - XRRGetScreenResources() takes half a second.
-
-    - Adam has now removed a workaround that caused some of the slowdown. 
-  
-  - If a DVI monitor is disconnected, you get "Unknown" for connection
-    status.
-
-  - If a VGA monitor is plugged in, then EDID information is not
-    available, even after running xrandr --verbose. The monitor has
-    to be plugged in at driver startup time, apparently.
-
-  - Logging out and logging back in often results in some random mode being
-    set. We need mode selection to not be completely screwed up.
-    Currently it is. 
-
-  - The set up at server startup needs to be fixed. *If* randr actually works,
-    then we might be able to do something sensible. 
-
-  - We need to revisit the idea that many monitors have broken EDID data.
-    This may be less widespread than previously believed.
-
-- It may be useful to return the connector names as identifiers instead
-  of relying on UTF-8 strings. Ie., have an enum
-
-	{ UNKNOWN, OTHER, DVI, VGA, HDMI, ...,  }
-
-  in addition to the string. The difference between UNKNOWN and OTHER is that
-  UNKNOWN means the driver doesn't know, whereas OTHER means it is something 
-  not listed in the enum (which could be listed in a later version).
-
-- Mouse cursor should be confined to the visible area. (It is already, I think)
-
-- It looks like EDID information is only available for one output
-  even though it is actually read according to the log file.
-  (nv, intel drivers)
-
-
-*********************************
-
-
-
-DONE:
-
-Server work:
-
-    - i830 laptop incorrectly reports BadMatch when you configure the
-      CRTC to drive both VGA and LVDS with the 1024x768 mode that both
-      outputs can handle. (It should return 'failed' if it can't do
-      that). Same for i945 laptop. It seems as if the same CRTC can't 
-      drive more than one output at the same time on Intel. 
-      
-      This was a client bug, but the documentation for SetCrtcConfig
-      should say that BadMatch will be returned if the outputs aren't
-      clones.
-
-GTK+ patch is in now.
-
-=== Add helper function
-
-
-+  if (screen_x11->randr12)
-+  {
-+       XRRScreenResources *sr;
-+    XRROutputInfo *output;
-+       gchar *retval;
-+       
-+    sr = XRRGetScreenResources ( screen_x11->xdisplay,
-+                                 screen_x11->xroot_window );
-+    
-+    output = XRRGetOutputInfo ( screen_x11->xdisplay,
-+                                sr,
-+                                (RROutput)screen_x11->act_outputs[monitor_num]
-);
-
-  Might be worthwhile to factor this out into a 
-  gdk_screen_get_output_info (screen, monitor_num)
-  helper function ? 
-
-Instead of cutting and pasting all over creation
-
-* Calling XRRGetScreenResources all the time is not going to fly. It
-  takes hundreds of milliseconds ... Even if it didn't, it wouldn't
-  be acceptable to do all those roundtrips.
-
-
-=== Some g_prints left
-
-
-=== Version check
-
-Should be (maj > 1) || (maj == 1 && min >= 2)
-
-
-=== Grep for TODO
-
-
-=== Setup XRRSelectInput()
-
-  You should call XRRSelectInput() at the same place where you are 
-  calling XSelectInput() right now. The right place to handle the 
-  XRandr events is the huge switch in gdkevents-x11.c:gdk_event_translate
-  Check out how other extension events are handled there, like
-  XKB, or XFixes.
-
-
-=== Lots of variable naming issues, such as act_output and noutput
-
-=== Needs to select the input, and hook it up to the signal
-
-=== Add version markers to API
-
-=== API to turn monitors on and off?
-
-- DPMS not exposed through randr, maybe should be
-
-       - DPMS is presumably a property of either an
-         output or a CRTC. Logically it's an output.
-
-- Need events when DPMS happens. Exposing the "screen saving on" on
-  dbus may not be good enough.
-
-=== Why does init_multihead_support() start by freeing monitors and
-outputs?
-
-=== Do we disable Xinerama support entirely when 1.2 is in use?
-
-=== We should expose information about what parts of the screen monitors
-are viewing.
-
-=== Make use of the EDID information?
-
-
--- details for X server --
-
-In nv driver SorSetOutputProperty should return TRUE for unknown
-properties. (Like the Intel driver does).
-
-Detecting plugged in
-
-- Periodically poll
-  - 
-
-  - One ddc probe takes 5 ms, according to a comment in the intel
-    driver. Running this twice a second would mean spending 1% of
-    overall time doing ddc polling, which is almost certainly not
-    acceptable.
-
-    1) Async I2C:
-
-	void I2CProbeAsync(..., callback, data);
-        Bool I2CPending()
-	void I2CUpdate()
-
-      In Dispatch, call I2CUpdate()
-      Before going idle, do
-
-            while (I2CPending())
-                 I2CUpdate()
-
-      Would need
-      	    RegisterDispatchFunction()  (Is this called Wakeup?)
-	    RegisterIdleFunction()
-
-      Note the idle function should have the option of saying: 
-      "check if something else happened; if not, call me again" and
-      "ok, I'm done - go idle". Otherwise, we would be blocking for
-      5 ms whenever the X server went idle. So actually the idle
-      function should be
-
-      	       if (I2CPending())
-	       {
-			I2CUpdate();
-			return TRUE;  /* call me again */
-               }
-               else
-	       {
-			return FALSE; /* I'm done */
-               }
-
-      What happens if another I2C requests come in while an async one
-      is pending? Most likely we simply finish whatever is going on,
-      then process the new request.
-
-      What happens if an X request takes so long that we get timeouts on
-      the i2c bus? Good question. Need to read the VESA ddc spec.
-
-    2) Run the polling in a separate thread.
- 
-       Probably crack.
-
-    3) Run the polling less, maybe once every three seconds. 
-
--- details for control panel --
-Screen changes
-       - Currently it is polling via rw_screen_refresh(), which will always emit
-         a screen-changed event. In reponse to this event the capplet currently
-	 checks whether anything changed physically about the setup. This means
-	 the capplet can't react to external changes to modes. On the other hand
-	 if it didn't
-Disallow combinations that would exceed the screen ranges.
-   - Note rotations 
-
-Give rw objects stable positions in memory so that they can be cached
-across screen_changed events.
-
-Add Clone Mode
-
-Drag and drop for the monitors
-     - 2 dimensional layout
-
-Store make and model in monitors.xml, then if serial numbers don't
-match, fall back to a make and model match. Users with an nfs mounted
-home directory should not have to reconfigure for each new system they
-log in to.
-
-Make sure text is scaled correctly
-
-Need to sanitize naming
-     RWOutput vs Output	- should probably be OutputInfo
-     rate vs. freq - decide on one
-
-Should probably reconsider the use of null terminated arrays. 
-Maybe lists would be better.
-
-Pick a fixed scale, so that two 1024x768 don't look like two 6x4.
-     - An alternative would be to draw a checkerboard pattern
-       below the monitors. 
-
-
-
-done:
-
-Add rotation
-
-Disable panel checkbox for now
-
-Patch into gnome-desktop
-
-Find out how to share code between gcc and gsd
-
-Make it assign coordinates correctly
-     - including computing correct screen size
-
diff --git a/panels/display/cc-display-panel.c b/panels/display/cc-display-panel.c
deleted file mode 100644
index b367ec2..0000000
--- a/panels/display/cc-display-panel.c
+++ /dev/null
@@ -1,3256 +0,0 @@
-/*
- * Copyright (C) 2007, 2008  Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Author: Soren Sandmann <sandmann@redhat.com>
- *
- */
-
-#include <config.h>
-#include <string.h>
-#include <stdlib.h>
-#include <sys/wait.h>
-
-#include "cc-display-panel.h"
-
-#include <gtk/gtk.h>
-#include <glib.h>
-#include "scrollarea.h"
-#define GNOME_DESKTOP_USE_UNSTABLE_API
-#include <libgnome-desktop/gnome-rr.h>
-#include <libgnome-desktop/gnome-rr-config.h>
-#include <gdk/gdkx.h>
-#include <X11/Xlib.h>
-#include <glib/gi18n.h>
-#include <gdesktop-enums.h>
-
-#include "cc-rr-labeler.h"
-
-CC_PANEL_REGISTER (CcDisplayPanel, cc_display_panel)
-
-#define DISPLAY_PANEL_PRIVATE(o) \
-  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_DISPLAY_PANEL, CcDisplayPanelPrivate))
-
-#define WID(s) GTK_WIDGET (gtk_builder_get_object (self->priv->builder, s))
-
-#define TOP_BAR_HEIGHT 10
-
-#define CLOCK_SCHEMA "org.gnome.desktop.interface"
-#define CLOCK_FORMAT_KEY "clock-format"
-
-/* The minimum supported size for the panel, see:
- * http://live.gnome.org/Design/SystemSettings */
-#define MINIMUM_WIDTH 675
-#define MINIMUM_HEIGHT 530
-
-#define UNITY_GSETTINGS_SCHEMA "org.compiz.unityshell"
-#define UNITY_GSETTINGS_PATH "/org/compiz/profiles/unity/plugins/unityshell/"
-#define UNITY_LAUNCHER_ALL_MONITORS_KEY "num-launchers"
-#define UNITY_STICKY_EDGE_KEY "launcher-capture-mouse"
-#define UNITY_UI_GSETTINGS_SCHEMA "com.canonical.Unity.Interface"
-#define UNITY_UI_SCALE_FACTOR_MONITOR "app-scale-factor-monitor"
-#define UNITY_UI_SCALE_FALLBACK_TO_MAX "app-fallback-to-maximum-scale-factor"
-#define UNITY2D_GSETTINGS_MAIN "com.canonical.Unity2d"
-#define UNITY2D_GSETTINGS_LAUNCHER "com.canonical.Unity2d.Launcher"
-
-#define DESKTOP_GSETTINGS_SCHEMA "com.ubuntu.user-interface"
-
-#define UI_SCALE_MIN 4.0
-#define UI_SCALE_MAX 32.0
-#define UI_SCALE_STEP 1.0
-#define UI_SCALE_DEFAULT 8.0
-
-enum {
-  TEXT_COL,
-  WIDTH_COL,
-  HEIGHT_COL,
-  RATE_COL,
-  SORT_COL,
-  ROTATION_COL,
-  NUM_COLS
-};
-
-struct _CcDisplayPanelPrivate
-{
-  GnomeRRScreen       *screen;
-  GnomeRRConfig  *current_configuration;
-  CcRRLabeler *labeler;
-  GnomeRROutputInfo         *current_output;
-
-  GSettings      *clock_settings;
-  GSettings      *unity_settings;
-  GSettings      *unity_ui_settings;
-  GSettings      *unity2d_settings_main;
-  GSettings      *unity2d_settings_launcher;
-  GSettings      *desktop_settings;
-  GtkBuilder     *builder;
-  guint           focus_id;
-
-  GtkWidget      *panel;
-  GtkWidget      *current_monitor_event_box;
-  GtkWidget      *current_monitor_label;
-  GtkWidget      *monitor_switch;
-  GtkListStore   *resolution_store;
-  GtkWidget      *resolution_combo;
-  GtkWidget      *rotation_combo;
-  GtkWidget      *clone_checkbox;
-  GtkWidget      *clone_label;
-  GtkWidget      *show_icon_checkbox;
-  GtkWidget      *ui_scale;
-  double         ui_prev_scale;
-
-  /* We store the event timestamp when the Apply button is clicked */
-  guint32         apply_button_clicked_timestamp;
-
-  GtkWidget      *area;
-  gboolean        ignore_gui_changes;
-  gboolean        dragging_top_bar;
-
-  /* These are used while we are waiting for the ApplyConfiguration method to be executed over D-bus */
-  GDBusProxy *proxy;
-};
-
-typedef struct
-{
-  int grab_x;
-  int grab_y;
-  int output_x;
-  int output_y;
-} GrabInfo;
-
-static void rebuild_gui (CcDisplayPanel *self);
-static void on_clone_changed (GtkWidget *box, gpointer data);
-static gboolean output_overlaps (GnomeRROutputInfo *output, GnomeRRConfig *config);
-static void select_current_output_from_dialog_position (CcDisplayPanel *self);
-static void monitor_switch_active_cb (GObject *object, GParamSpec *pspec, gpointer data);
-static void get_geometry (GnomeRROutputInfo *output, int *w, int *h);
-static void apply_configuration_returned_cb (GObject *proxy, GAsyncResult *res, gpointer data);
-static gboolean get_clone_size (GnomeRRScreen *screen, int *width, int *height);
-static gboolean output_info_supports_mode (CcDisplayPanel *self, GnomeRROutputInfo *info, int width, int height);
-static char *make_resolution_string (int width, int height);
-static GObject *cc_display_panel_constructor (GType                  gtype,
-					      guint                  n_properties,
-					      GObjectConstructParam *properties);
-static void on_screen_changed (GnomeRRScreen *scr, gpointer data);
-static void refresh_unity_launcher_placement (CcDisplayPanel *self);
-static void refresh_unity_monitor_scale (CcDisplayPanel *self);
-static gboolean unity_launcher_on_all_monitors (GSettings *settings);
-
-static void
-cc_display_panel_get_property (GObject    *object,
-                               guint       property_id,
-                               GValue     *value,
-                               GParamSpec *pspec)
-{
-  switch (property_id)
-    {
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-    }
-}
-
-static void
-cc_display_panel_set_property (GObject      *object,
-                               guint         property_id,
-                               const GValue *value,
-                               GParamSpec   *pspec)
-{
-  switch (property_id)
-    {
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-    }
-}
-
-static void
-cc_display_panel_dispose (GObject *object)
-{
-  G_OBJECT_CLASS (cc_display_panel_parent_class)->dispose (object);
-}
-
-static void
-cc_display_panel_finalize (GObject *object)
-{
-  CcDisplayPanel *self;
-  CcShell *shell;
-  GtkWidget *toplevel;
-
-  self = CC_DISPLAY_PANEL (object);
-
-  g_signal_handlers_disconnect_by_func (self->priv->screen, on_screen_changed, self);
-  g_object_unref (self->priv->screen);
-  g_object_unref (self->priv->builder);
-
-  if (self->priv->clock_settings != NULL)
-    g_object_unref (self->priv->clock_settings);
-
-  if (self->priv->unity2d_settings_main != NULL)
-    g_object_unref (self->priv->unity2d_settings_main);
-  if (self->priv->unity2d_settings_launcher != NULL)
-    g_object_unref (self->priv->unity2d_settings_launcher);
-  if (self->priv->unity_settings != NULL)
-    g_object_unref (self->priv->unity_settings);
-  if (self->priv->unity_ui_settings != NULL)
-    g_object_unref (self->priv->unity_ui_settings);
-  if (self->priv->desktop_settings != NULL)
-    g_object_unref (self->priv->desktop_settings);
-
-  shell = cc_panel_get_shell (CC_PANEL (self));
-  if (shell != NULL)
-    {
-      toplevel = cc_shell_get_toplevel (shell);
-      if (toplevel != NULL)
-        g_signal_handler_disconnect (G_OBJECT (toplevel),
-                                     self->priv->focus_id);
-    }
-
-  cc_rr_labeler_hide (self->priv->labeler);
-  g_object_unref (self->priv->labeler);
-
-  G_OBJECT_CLASS (cc_display_panel_parent_class)->finalize (object);
-}
-
-static const char *
-cc_display_panel_get_help_uri (CcPanel *panel)
-{
-  if (!g_strcmp0(g_getenv("XDG_CURRENT_DESKTOP"), "Unity"))
-    return "help:ubuntu-help/prefs-display";
-  else
-    return "help:gnome-help/prefs-display";
-}
-
-static void
-cc_display_panel_class_init (CcDisplayPanelClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  CcPanelClass *panel_class = CC_PANEL_CLASS (klass);
-
-  g_type_class_add_private (klass, sizeof (CcDisplayPanelPrivate));
-
-  panel_class->get_help_uri = cc_display_panel_get_help_uri;
-
-  object_class->constructor = cc_display_panel_constructor;
-  object_class->get_property = cc_display_panel_get_property;
-  object_class->set_property = cc_display_panel_set_property;
-  object_class->dispose = cc_display_panel_dispose;
-  object_class->finalize = cc_display_panel_finalize;
-}
-
-static void
-error_message (CcDisplayPanel *self, const char *primary_text, const char *secondary_text)
-{
-  GtkWidget *toplevel;
-  GtkWidget *dialog;
-
-  if (self && self->priv->panel)
-    toplevel = gtk_widget_get_toplevel (self->priv->panel);
-  else
-    toplevel = NULL;
-
-  dialog = gtk_message_dialog_new (GTK_WINDOW (toplevel),
-                                   GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
-                                   GTK_MESSAGE_ERROR,
-                                   GTK_BUTTONS_CLOSE,
-                                   "%s", primary_text);
-
-  if (secondary_text)
-    gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog), "%s", secondary_text);
-
-  gtk_dialog_run (GTK_DIALOG (dialog));
-  gtk_widget_destroy (dialog);
-}
-
-static gboolean
-is_unity_session (void)
-{
-  return (g_strcmp0 (g_getenv("XDG_CURRENT_DESKTOP"), "Unity") == 0);
-}
-
-static gboolean
-should_show_resolution (gint output_width,
-                        gint output_height,
-                        gint width,
-                        gint height)
-{
-  if (width >= MIN (output_width, MINIMUM_WIDTH) &&
-      height >= MIN (output_height, MINIMUM_HEIGHT))
-    {
-      return TRUE;
-    }
-  return FALSE;
-}
-
-static void
-on_screen_changed (GnomeRRScreen *scr,
-                   gpointer data)
-{
-  GnomeRRConfig *current;
-  CcDisplayPanel *self = data;
-
-  current = gnome_rr_config_new_current (self->priv->screen, NULL);
-  gnome_rr_config_ensure_primary (current);
-
-  if (self->priv->current_configuration)
-    g_object_unref (self->priv->current_configuration);
-
-  self->priv->current_configuration = current;
-  self->priv->current_output = NULL;
-
-  if (self->priv->labeler) {
-    cc_rr_labeler_hide (self->priv->labeler);
-    g_object_unref (self->priv->labeler);
-  }
-
-  self->priv->labeler = cc_rr_labeler_new (self->priv->current_configuration);
-  if (gtk_widget_has_focus (self->priv->panel))
-     cc_rr_labeler_show (self->priv->labeler);
-
-  select_current_output_from_dialog_position (self);
-
-  if (is_unity_session ())
-    {
-      refresh_unity_launcher_placement (self);
-      refresh_unity_monitor_scale (self);
-    }
-}
-
-static void
-on_viewport_changed (FooScrollArea *scroll_area,
-                     GdkRectangle  *old_viewport,
-                     GdkRectangle  *new_viewport)
-{
-  foo_scroll_area_set_size (scroll_area,
-                            new_viewport->width,
-                            new_viewport->height);
-
-  foo_scroll_area_invalidate (scroll_area);
-}
-
-static void
-layout_set_font (PangoLayout *layout, const char *font)
-{
-  PangoFontDescription *desc =
-    pango_font_description_from_string (font);
-
-  if (desc)
-    {
-      pango_layout_set_font_description (layout, desc);
-
-      pango_font_description_free (desc);
-    }
-}
-
-static void
-clear_combo (GtkWidget *widget)
-{
-  GtkComboBox *box = GTK_COMBO_BOX (widget);
-  GtkTreeModel *model = gtk_combo_box_get_model (box);
-  GtkListStore *store = GTK_LIST_STORE (model);
-
-  gtk_list_store_clear (store);
-}
-
-typedef struct
-{
-  const char *text;
-  gboolean found;
-  GtkTreeIter iter;
-} ForeachInfo;
-
-static gboolean
-foreach (GtkTreeModel *model,
-         GtkTreePath *path,
-         GtkTreeIter *iter,
-         gpointer data)
-{
-  ForeachInfo *info = data;
-  char *text = NULL;
-
-  gtk_tree_model_get (model, iter, TEXT_COL, &text, -1);
-
-  g_assert (text != NULL);
-
-  if (strcmp (info->text, text) == 0)
-    {
-      info->found = TRUE;
-      info->iter = *iter;
-      return TRUE;
-    }
-
-  return FALSE;
-}
-
-static void
-add_key (GtkTreeModel *model,
-         const char *text,
-         gboolean preferred,
-         int width, int height, int rate,
-         GnomeRRRotation rotation)
-{
-  ForeachInfo info;
-
-  info.text = text;
-  info.found = FALSE;
-
-  gtk_tree_model_foreach (model, foreach, &info);
-
-  if (!info.found)
-    {
-      GtkTreeIter iter;
-      g_debug ("adding %s with rate %d Hz", text, rate);
-      gtk_list_store_insert_with_values (GTK_LIST_STORE (model), &iter, -1,
-                                         TEXT_COL, text,
-                                         WIDTH_COL, width,
-                                         HEIGHT_COL, height,
-                                         RATE_COL, rate,
-                                         SORT_COL, width * 10000 + height,
-                                         ROTATION_COL, rotation,
-                                         -1);
-      return;
-    }
-
-  /* Look, the preferred output, replace the old one */
-  if (preferred)
-    {
-      g_debug ("replacing %s with rate %d Hz (preferred mode)", text, rate);
-      gtk_list_store_set (GTK_LIST_STORE (model), &info.iter,
-                          RATE_COL, rate,
-                          -1);
-      return;
-    }
-
-  {
-    int old_rate;
-
-    gtk_tree_model_get (model, &info.iter,
-                        RATE_COL, &old_rate,
-                        -1);
-
-    /* Higher refresh rate */
-    if (rate > old_rate)
-    {
-      g_debug ("replacing %s with rate %d Hz (old rate: %d)", text, rate, old_rate);
-      gtk_list_store_set (GTK_LIST_STORE (model), &info.iter,
-                          RATE_COL, rate,
-                          -1);
-      return;
-    }
-  }
-
-  g_debug ("not adding %s with rate %d Hz (higher rate already there)", text, rate);
-}
-
-static void
-add_mode (CcDisplayPanel *self,
-	  GnomeRRMode *mode,
-	  gint  output_width,
-	  gint  output_height,
-	  guint preferred_id)
-{
-  int width, height, rate;
-
-  width = gnome_rr_mode_get_width (mode);
-  height = gnome_rr_mode_get_height (mode);
-  rate = gnome_rr_mode_get_freq (mode);
-
-  if (should_show_resolution (output_width, output_height, width, height))
-    {
-      char *text;
-      gboolean preferred;
-
-      preferred = (gnome_rr_mode_get_id (mode) == preferred_id);
-      text = make_resolution_string (width, height);
-      add_key (gtk_combo_box_get_model (GTK_COMBO_BOX (self->priv->resolution_combo)),
-               text, preferred, width, height, rate, -1);
-      g_free (text);
-    }
-}
-
-
-
-static gboolean
-combo_select (GtkWidget *widget, const char *text)
-{
-  GtkComboBox *box = GTK_COMBO_BOX (widget);
-  GtkTreeModel *model = gtk_combo_box_get_model (box);
-  ForeachInfo info;
-
-  info.text = text;
-  info.found = FALSE;
-
-  gtk_tree_model_foreach (model, foreach, &info);
-
-  if (!info.found)
-    return FALSE;
-
-  gtk_combo_box_set_active_iter (box, &info.iter);
-  return TRUE;
-}
-
-static GnomeRRMode **
-get_current_modes (CcDisplayPanel *self)
-{
-  GnomeRROutput *output;
-
-  if (gnome_rr_config_get_clone (self->priv->current_configuration))
-    {
-      return gnome_rr_screen_list_clone_modes (self->priv->screen);
-    }
-  else
-    {
-      if (!self->priv->current_output)
-        return NULL;
-
-      output = gnome_rr_screen_get_output_by_name (self->priv->screen,
-                                                   gnome_rr_output_info_get_name (self->priv->current_output));
-
-      if (!output)
-        return NULL;
-
-      return gnome_rr_output_list_modes (output);
-    }
-}
-
-static void
-rebuild_rotation_combo (CcDisplayPanel *self)
-{
-  typedef struct
-  {
-    GnomeRRRotation	rotation;
-    const char *	name;
-  } RotationInfo;
-  static const RotationInfo rotations[] = {
-    { GNOME_RR_ROTATION_0, NC_("display panel, rotation", "Normal") },
-    { GNOME_RR_ROTATION_90, NC_("display panel, rotation", "Counterclockwise") },
-    { GNOME_RR_ROTATION_270, NC_("display panel, rotation", "Clockwise") },
-    { GNOME_RR_ROTATION_180, NC_("display panel, rotation", "180 Degrees") },
-  };
-  const char *selection;
-  GnomeRRRotation current;
-  int i;
-
-  clear_combo (self->priv->rotation_combo);
-
-  gtk_widget_set_sensitive (self->priv->rotation_combo,
-                            self->priv->current_output && gnome_rr_output_info_is_active (self->priv->current_output));
-
-  if (!self->priv->current_output)
-    return;
-
-  current = gnome_rr_output_info_get_rotation (self->priv->current_output);
-
-  selection = NULL;
-  for (i = 0; i < G_N_ELEMENTS (rotations); ++i)
-    {
-      const RotationInfo *info = &(rotations[i]);
-
-      gnome_rr_output_info_set_rotation (self->priv->current_output, info->rotation);
-
-      /* NULL-GError --- FIXME: we should say why this rotation is not available! */
-      if (gnome_rr_config_applicable (self->priv->current_configuration, self->priv->screen, NULL))
-        {
-          add_key (gtk_combo_box_get_model (GTK_COMBO_BOX (self->priv->rotation_combo)), g_dpgettext2 (NULL, "display panel, rotation", info->name), FALSE, 0, 0, 0, info->rotation);
-
-          if (info->rotation == current)
-            selection = g_dpgettext2 (NULL, "display panel, rotation", info->name);
-        }
-    }
-
-  gnome_rr_output_info_set_rotation (self->priv->current_output, current);
-
-  if (!(selection && combo_select (self->priv->rotation_combo, selection)))
-    gtk_combo_box_set_active (GTK_COMBO_BOX (self->priv->rotation_combo), 0);
-}
-
-static GVariant*
-add_dict_entry (GVariant *dict, const char *key, int value)
-{
-  GVariantBuilder builder;
-  GVariantIter iter;
-
-  const gchar *k;
-  guint32 v;
-
-  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{si}"));
-  g_variant_iter_init (&iter, dict);
-
-  while (g_variant_iter_next (&iter, "{&si}", &k, &v))
-  {
-    if (!g_str_equal (k, key))
-      g_variant_builder_add (&builder, "{si}", k, v);
-  }
-  g_variant_builder_add (&builder, "{si}", key, value);
-
-  return g_variant_builder_end (&builder);
-}
-
-static void
-rebuild_ui_scale (CcDisplayPanel *self)
-{
-  int value;
-  float t;
-
-  GVariant *dict;
-  GVariant *new_dict;
-
-  GtkAdjustment *adj = gtk_range_get_adjustment (GTK_RANGE(self->priv->ui_scale));
-  const char *monitor_name = gnome_rr_output_info_get_name (self->priv->current_output);
-  if (!monitor_name)
-  {
-    g_warning("Failed to get monitor name.");
-    return;
-  }
-
-  gtk_adjustment_set_step_increment (adj, UI_SCALE_STEP);
-  gtk_adjustment_set_upper (adj, UI_SCALE_MAX);
-  gtk_adjustment_set_lower (adj, UI_SCALE_MIN);
-  gtk_scale_set_digits (GTK_SCALE(self->priv->ui_scale), 0);
-  gtk_scale_add_mark (GTK_SCALE(self->priv->ui_scale), UI_SCALE_DEFAULT, GTK_POS_TOP, NULL);
-
-  dict = g_settings_get_value (self->priv->desktop_settings, "scale-factor");
-  if (!g_variant_lookup (dict, monitor_name, "i", &value))
-  {
-    value = UI_SCALE_DEFAULT;
-    self->priv->ui_prev_scale = value;
-  }
-  new_dict = add_dict_entry (dict, monitor_name, value);
-  g_settings_set_value (self->priv->desktop_settings, "scale-factor", new_dict);
-  gtk_adjustment_set_value (adj, value);
-  g_variant_unref (dict);
-}
-
-static int
-count_active_outputs (CcDisplayPanel *self)
-{
-  int i, count = 0;
-  GnomeRROutputInfo **outputs = gnome_rr_config_get_outputs (self->priv->current_configuration);
-
-  for (i = 0; outputs[i] != NULL; ++i)
-    {
-      if (gnome_rr_output_info_is_active (outputs[i]))
-        count++;
-    }
-
-  return count;
-}
-
-#if 0
-static int
-count_all_outputs (GnomeRRConfig *config)
-{
-  int i;
-  GnomeRROutputInfo **outputs = gnome_rr_config_get_outputs (config);
-
-  for (i = 0; outputs[i] != NULL; i++)
-    ;
-
-  return i;
-}
-#endif
-
-/* Computes whether "Mirror displays" (clone mode) is supported based on these criteria:
- *
- * 1. There is an available size for cloning.
- *
- * 2. There are 2 or more connected outputs that support that size.
- */
-static gboolean
-mirror_screens_is_supported (CcDisplayPanel *self)
-{
-  int clone_width, clone_height;
-  gboolean have_clone_size;
-  gboolean mirror_is_supported;
-
-  mirror_is_supported = FALSE;
-
-  have_clone_size = get_clone_size (self->priv->screen, &clone_width, &clone_height);
-
-  if (have_clone_size) {
-    int i;
-    int num_outputs_with_clone_size;
-    GnomeRROutputInfo **outputs = gnome_rr_config_get_outputs (self->priv->current_configuration);
-
-    num_outputs_with_clone_size = 0;
-
-    for (i = 0; outputs[i] != NULL; i++)
-      {
-         /* We count the connected outputs that support the clone size.  It
-          * doesn't matter if those outputs aren't actually On currently; we
-          * will turn them on in on_clone_changed().
-          */
-         if (gnome_rr_output_info_is_connected (outputs[i]) && output_info_supports_mode (self, outputs[i], clone_width, clone_height))
-           num_outputs_with_clone_size++;
-      }
-
-    if (num_outputs_with_clone_size >= 2)
-      mirror_is_supported = TRUE;
-  }
-
-  return mirror_is_supported;
-}
-
-static void
-rebuild_mirror_screens (CcDisplayPanel *self)
-{
-  gboolean mirror_is_active;
-  gboolean mirror_is_supported;
-
-  g_signal_handlers_block_by_func (self->priv->clone_checkbox, G_CALLBACK (on_clone_changed), self);
-
-  mirror_is_active = self->priv->current_configuration && gnome_rr_config_get_clone (self->priv->current_configuration);
-
-  /* If mirror_is_active, then it *must* be possible to turn mirroring off */
-  mirror_is_supported = mirror_is_active || mirror_screens_is_supported (self);
-
-  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (self->priv->clone_checkbox), mirror_is_active);
-  gtk_widget_set_sensitive (self->priv->clone_checkbox, mirror_is_supported);
-  gtk_widget_set_sensitive (self->priv->clone_label, mirror_is_supported);
-
-  /* set inactive the launcher placement choice */
-  gtk_widget_set_sensitive (WID ("launcher_placement_combo"), !mirror_is_active);
-  gtk_widget_set_sensitive (WID ("stickyedge_switch"), !mirror_is_active);
-  gtk_widget_set_sensitive (WID ("ui_scale_monitor_combo"), !mirror_is_active);
-
-  g_signal_handlers_unblock_by_func (self->priv->clone_checkbox, G_CALLBACK (on_clone_changed), self);
-}
-
-static char *
-mirror_monitor_name (void)
-{
-  /* Keep this string in sync with gnome-desktop/libgnome-desktop/gnome-rr-labeler.c */
-
-  /* Translators:  this is the feature where what you see on your laptop's
-   * screen is the same as your external projector.  Here, "Mirrored" is being
-   * used as an adjective.  For example, the Spanish translation could be
-   * "Pantallas en Espejo".
-   */
-  return g_strdup (_("Mirrored Displays"));
-}
-
-static void
-rebuild_current_monitor_label (CcDisplayPanel *self)
-{
-  gchar *str;
-  GdkRGBA color;
-  gboolean use_color;
-
-  if (self->priv->current_output)
-    {
-      if (gnome_rr_config_get_clone (self->priv->current_configuration))
-        {
-          gchar *str = mirror_monitor_name ();
-          gtk_label_set_text (GTK_LABEL (self->priv->current_monitor_label), str);
-          g_free (str);
-        }
-      else
-        {
-          str = gnome_rr_output_info_get_display_name (self->priv->current_output);
-          gtk_label_set_text (GTK_LABEL (self->priv->current_monitor_label), str);
-        }
-
-      cc_rr_labeler_get_rgba_for_output (self->priv->labeler, self->priv->current_output, &color);
-      use_color = TRUE;
-    }
-  else
-    {
-      gtk_label_set_text (GTK_LABEL (self->priv->current_monitor_label), _("Monitor"));
-      use_color = FALSE;
-    }
-
-  if (use_color)
-    {
-      GdkRGBA black = { 0, 0, 0, 1.0 };
-
-      gtk_widget_override_background_color (self->priv->current_monitor_event_box,
-                                            gtk_widget_get_state_flags (self->priv->current_monitor_event_box),
-                                            &color);
-
-      /* Make the label explicitly black.  We don't want it to follow the
-       * theme's colors, since the label is always shown against a light
-       * pastel background.  See bgo#556050
-       */
-      gtk_widget_override_color (self->priv->current_monitor_label,
-                                 gtk_widget_get_state_flags (self->priv->current_monitor_label),
-                                 &black);
-    }
-  else
-    {
-      /* Remove any modifications we did on the label's color */
-      gtk_widget_override_color (self->priv->current_monitor_label,
-                                 gtk_widget_get_state_flags (self->priv->current_monitor_label),
-                                 NULL);
-    }
-
-    gtk_event_box_set_visible_window (GTK_EVENT_BOX (self->priv->current_monitor_event_box), use_color);
-}
-
-static void
-rebuild_on_off_radios (CcDisplayPanel *self)
-{
-  gboolean sensitive;
-  gboolean on_active;
-
-  g_signal_handlers_block_by_func (self->priv->monitor_switch, G_CALLBACK (monitor_switch_active_cb), self);
-
-  sensitive = FALSE;
-  on_active = FALSE;
-
-  if (!gnome_rr_config_get_clone (self->priv->current_configuration) && self->priv->current_output)
-    {
-      if (count_active_outputs (self) > 1 || !gnome_rr_output_info_is_active (self->priv->current_output))
-        sensitive = TRUE;
-      else
-        sensitive = FALSE;
-
-      on_active = gnome_rr_output_info_is_active (self->priv->current_output);
-    }
-
-  gtk_widget_set_sensitive (self->priv->monitor_switch, sensitive);
-
-  gtk_switch_set_active (GTK_SWITCH (self->priv->monitor_switch), on_active);
-
-  g_signal_handlers_unblock_by_func (self->priv->monitor_switch, G_CALLBACK (monitor_switch_active_cb), self);
-}
-
-static char *
-make_resolution_string (int width, int height)
-{
-  int ratio;
-  const char *aspect = NULL;
-
-  if (width && height) {
-    if (width > height)
-      ratio = width * 10 / height;
-    else
-      ratio = height * 10 / width;
-
-    switch (ratio) {
-    case 13:
-      aspect = "4:3";
-      break;
-    case 16:
-      aspect = "16:10";
-      break;
-    case 17:
-      aspect = "16:9";
-      break;
-    case 23:
-      aspect = "21:9";
-      break;
-    case 12:
-      aspect = "5:4";
-      break;
-      /* This catches 1.5625 as well (1600x1024) when maybe it shouldn't. */
-    case 15:
-      aspect = "3:2";
-      break;
-    case 18:
-      aspect = "9:5";
-      break;
-    case 10:
-      aspect = "1:1";
-      break;
-    }
-  }
-
-  if (aspect != NULL)
-    return g_strdup_printf (_("%d x %d (%s)"), width, height, aspect);
-  else
-    return g_strdup_printf (_("%d x %d"), width, height);
-}
-
-static void
-find_best_mode (GnomeRRMode **modes, int *out_width, int *out_height)
-{
-  int i;
-
-  *out_width = 0;
-  *out_height = 0;
-
-  for (i = 0; modes[i] != NULL; i++)
-    {
-      int w, h;
-
-      w = gnome_rr_mode_get_width (modes[i]);
-      h = gnome_rr_mode_get_height (modes[i]);
-
-      if (w * h > *out_width * *out_height)
-        {
-          *out_width = w;
-          *out_height = h;
-        }
-    }
-}
-
-static void
-rebuild_resolution_combo (CcDisplayPanel *self)
-{
-  int i;
-  GnomeRRMode **modes;
-  GnomeRRMode *mode;
-  char *current;
-  int output_width, output_height;
-  guint32 preferred_id;
-  GnomeRROutput *output;
-
-  clear_combo (self->priv->resolution_combo);
-
-  if (!(modes = get_current_modes (self))
-      || !self->priv->current_output
-      || !gnome_rr_output_info_is_active (self->priv->current_output))
-    {
-      gtk_widget_set_sensitive (self->priv->resolution_combo, FALSE);
-      return;
-    }
-
-  g_assert (self->priv->current_output != NULL);
-
-  gnome_rr_output_info_get_geometry (self->priv->current_output, NULL, NULL, &output_width, &output_height);
-  g_assert (output_width != 0 && output_height != 0);
-
-  gtk_widget_set_sensitive (self->priv->resolution_combo, TRUE);
-
-  output = gnome_rr_screen_get_output_by_name (self->priv->screen,
-                                               gnome_rr_output_info_get_name (self->priv->current_output));
-  mode = gnome_rr_output_get_preferred_mode (output);
-  preferred_id = gnome_rr_mode_get_id (mode);
-
-  for (i = 0; modes[i] != NULL; ++i)
-    add_mode (self, modes[i], output_width, output_height, preferred_id);
-
-  /* And force the preferred mode in the drop-down (when not in clone mode)
-   * https://bugzilla.gnome.org/show_bug.cgi?id=680969 */
-  if (!gnome_rr_config_get_clone (self->priv->current_configuration))
-   add_mode (self, mode, output_width, output_height, preferred_id);
-
-  current = make_resolution_string (output_width, output_height);
-
-  if (!combo_select (self->priv->resolution_combo, current))
-    {
-      int best_w, best_h;
-      char *str;
-
-      find_best_mode (modes, &best_w, &best_h);
-      str = make_resolution_string (best_w, best_h);
-      combo_select (self->priv->resolution_combo, str);
-      g_free (str);
-    }
-
-  g_free (current);
-}
-
-static void
-rebuild_gui (CcDisplayPanel *self)
-{
-  /* We would break spectacularly if we recursed, so
-   * just assert if that happens
-   */
-  g_assert (self->priv->ignore_gui_changes == FALSE);
-
-  self->priv->ignore_gui_changes = TRUE;
-
-  rebuild_mirror_screens (self);
-  rebuild_current_monitor_label (self);
-  rebuild_on_off_radios (self);
-  rebuild_resolution_combo (self);
-  rebuild_rotation_combo (self);
-  rebuild_ui_scale (self);
-  refresh_unity_launcher_placement (self);
-  refresh_unity_monitor_scale (self);
-
-  self->priv->ignore_gui_changes = FALSE;
-}
-
-static gboolean
-get_mode (GtkWidget *widget, int *width, int *height, int *rate, GnomeRRRotation *rot)
-{
-  GtkTreeIter iter;
-  GtkTreeModel *model;
-  GtkComboBox *box = GTK_COMBO_BOX (widget);
-  int dummy;
-
-  if (!gtk_combo_box_get_active_iter (box, &iter))
-    return FALSE;
-
-  if (!width)
-    width = &dummy;
-
-  if (!height)
-    height = &dummy;
-
-  if (!rate)
-    rate = &dummy;
-
-  if (!rot)
-    rot = (GnomeRRRotation *)&dummy;
-
-  model = gtk_combo_box_get_model (box);
-  gtk_tree_model_get (model, &iter,
-                      WIDTH_COL, width,
-                      HEIGHT_COL, height,
-                      RATE_COL, rate,
-                      ROTATION_COL, rot,
-                      -1);
-
-  return TRUE;
-
-}
-
-static void
-on_rotation_changed (GtkComboBox *box, gpointer data)
-{
-  CcDisplayPanel *self = data;
-  GnomeRRRotation rotation;
-
-  if (!self->priv->current_output)
-    return;
-
-  if (get_mode (self->priv->rotation_combo, NULL, NULL, NULL, &rotation))
-    gnome_rr_output_info_set_rotation (self->priv->current_output, rotation);
-
-  foo_scroll_area_invalidate (FOO_SCROLL_AREA (self->priv->area));
-}
-
-static gboolean
-on_ui_scale_button_press (GtkWidget *ui_scale, GdkEvent *ev, gpointer data)
-{
-  CcDisplayPanel *self = data;
-  self->priv->ui_prev_scale = gtk_range_get_value (GTK_RANGE(ui_scale));
-
-  return FALSE; /* gtk should still process this event */
-}
-
-static gboolean
-on_ui_scale_button_release (GtkWidget *ui_scale, GdkEvent *ev, gpointer data)
-{
-  const char *monitor_name;
-  CcDisplayPanel *self = data;
-  int value = (int)gtk_range_get_value (GTK_RANGE(ui_scale));
-
-  if (value != self->priv->ui_prev_scale)
-  {
-    GVariant *dict;
-    GVariant *new_dict;
-
-    monitor_name = gnome_rr_output_info_get_name (self->priv->current_output);
-    if (!monitor_name)
-    {
-      g_warning("Failed to get monitor name.");
-      return FALSE;
-    }
-
-    dict = g_settings_get_value (self->priv->desktop_settings, "scale-factor");
-    new_dict = add_dict_entry (dict, monitor_name, value);
-    g_settings_set_value (self->priv->desktop_settings, "scale-factor", new_dict);
-    g_variant_unref (dict);
-  }
-
-  return FALSE;  /* gtk should still process this event */
-}
-
-static gchar*
-on_ui_scale_format_value (GtkScale *ui_scale, gdouble value)
-{
-  return g_strdup_printf ("%.3g", value / 8.0);
-}
-
-static void
-select_resolution_for_current_output (CcDisplayPanel *self)
-{
-  GnomeRRMode **modes;
-  int width, height;
-  int x,y;
-  gnome_rr_output_info_get_geometry (self->priv->current_output, &x, &y, NULL, NULL);
-
-  width = gnome_rr_output_info_get_preferred_width (self->priv->current_output);
-  height = gnome_rr_output_info_get_preferred_height (self->priv->current_output);
-
-  if (width != 0 && height != 0)
-    {
-      gnome_rr_output_info_set_geometry (self->priv->current_output, x, y, width, height);
-      return;
-    }
-
-  modes = get_current_modes (self);
-  if (!modes)
-    return;
-
-  find_best_mode (modes, &width, &height);
-
-  gnome_rr_output_info_set_geometry (self->priv->current_output, x, y, width, height);
-}
-
-static void
-monitor_switch_active_cb (GObject    *object,
-                          GParamSpec *pspec,
-                          gpointer    data)
-{
-  CcDisplayPanel *self = data;
-  gboolean value;
-
-  if (!self->priv->current_output)
-    return;
-
-  value = gtk_switch_get_active (GTK_SWITCH (object));
-
-  if (value)
-    {
-      gnome_rr_output_info_set_active (self->priv->current_output, TRUE);
-      select_resolution_for_current_output (self);
-    }
-  else
-    {
-      gnome_rr_output_info_set_active (self->priv->current_output, FALSE);
-      gnome_rr_config_ensure_primary (self->priv->current_configuration);
-    }
-
-  rebuild_gui (self);
-  foo_scroll_area_invalidate (FOO_SCROLL_AREA (self->priv->area));
-}
-
-static void
-realign_outputs_after_resolution_change (CcDisplayPanel *self, GnomeRROutputInfo *output_that_changed, int old_width, int old_height)
-{
-  /* We find the outputs that were below or to the right of the output that
-   * changed, and realign them; we also do that for outputs that shared the
-   * right/bottom edges with the output that changed.  The outputs that are
-   * above or to the left of that output don't need to change.
-   */
-
-  int i;
-  int old_right_edge, old_bottom_edge;
-  int dx, dy;
-  int x, y, width, height;
-  GnomeRROutputInfo **outputs;
-
-  g_assert (self->priv->current_configuration != NULL);
-
-  gnome_rr_output_info_get_geometry (output_that_changed, &x, &y, &width, &height); 
-
-  if (width == old_width && height == old_height)
-    return;
-
-  old_right_edge = x + old_width;
-  old_bottom_edge = y + old_height;
-
-  dx = width - old_width;
-  dy = height - old_height;
-
-  outputs = gnome_rr_config_get_outputs (self->priv->current_configuration);
-
-  for (i = 0; outputs[i] != NULL; i++)
-    {
-      int output_x, output_y;
-      int output_width, output_height;
-
-      if (outputs[i] == output_that_changed || !gnome_rr_output_info_is_connected (outputs[i]))
-        continue;
-
-      gnome_rr_output_info_get_geometry (outputs[i], &output_x, &output_y, &output_width, &output_height);
-
-      if (output_x >= old_right_edge)
-         output_x += dx;
-      else if (output_x + output_width == old_right_edge)
-         output_x = x + width - output_width;
-
-      if (output_y >= old_bottom_edge)
-         output_y += dy;
-      else if (output_y + output_height == old_bottom_edge)
-         output_y = y + height - output_height;
-
-      gnome_rr_output_info_set_geometry (outputs[i], output_x, output_y, output_width, output_height);
-    }
-}
-
-static void
-on_resolution_changed (GtkComboBox *box, gpointer data)
-{
-  CcDisplayPanel *self = data;
-  int old_width, old_height;
-  int x,y;
-  int width;
-  int height;
-
-  if (!self->priv->current_output)
-    return;
-
-  gnome_rr_output_info_get_geometry (self->priv->current_output, &x, &y, &old_width, &old_height);
-
-  if (get_mode (self->priv->resolution_combo, &width, &height, NULL, NULL))
-    {
-      gnome_rr_output_info_set_geometry (self->priv->current_output, x, y, width, height);
-
-      if (width == 0 || height == 0)
-        gnome_rr_output_info_set_active (self->priv->current_output, FALSE);
-      else
-        gnome_rr_output_info_set_active (self->priv->current_output, TRUE);
-    }
-
-  realign_outputs_after_resolution_change (self, self->priv->current_output, old_width, old_height);
-
-  rebuild_rotation_combo (self);
-
-  foo_scroll_area_invalidate (FOO_SCROLL_AREA (self->priv->area));
-}
-
-static void
-lay_out_outputs_horizontally (CcDisplayPanel *self)
-{
-  int i;
-  int x;
-  GnomeRROutputInfo **outputs;
-
-  /* Lay out all the monitors horizontally when "mirror screens" is turned
-   * off, to avoid having all of them overlapped initially.  We put the
-   * outputs turned off on the right-hand side.
-   */
-
-  x = 0;
-
-  /* First pass, all "on" outputs */
-  outputs = gnome_rr_config_get_outputs (self->priv->current_configuration);
-
-  for (i = 0; outputs[i]; ++i)
-    {
-      int width, height;
-      if (gnome_rr_output_info_is_connected (outputs[i]) && gnome_rr_output_info_is_active (outputs[i]))
-        {
-          gnome_rr_output_info_get_geometry (outputs[i], NULL, NULL, &width, &height);
-          gnome_rr_output_info_set_geometry (outputs[i], x, 0, width, height);
-          x += width;
-        }
-    }
-
-  /* Second pass, all the black screens */
-
-    for (i = 0; outputs[i]; ++i)
-    {
-      int width, height;
-      if (!(gnome_rr_output_info_is_connected (outputs[i]) && gnome_rr_output_info_is_active (outputs[i])))
-        {
-          gnome_rr_output_info_get_geometry (outputs[i], NULL, NULL, &width, &height);
-          gnome_rr_output_info_set_geometry (outputs[i], x, 0, width, height);
-          x += width;
-        }
-    }
-
-}
-
-/* FIXME: this function is copied from gnome-settings-daemon/plugins/xrandr/gsd-xrandr-manager.c.
- * Do we need to put this function in gnome-desktop for public use?
- */
-static gboolean
-get_clone_size (GnomeRRScreen *screen, int *width, int *height)
-{
-  GnomeRRMode **modes = gnome_rr_screen_list_clone_modes (screen);
-  int best_w, best_h;
-  int i;
-
-  best_w = 0;
-  best_h = 0;
-
-  for (i = 0; modes[i] != NULL; ++i) {
-    GnomeRRMode *mode = modes[i];
-    int w, h;
-
-    w = gnome_rr_mode_get_width (mode);
-    h = gnome_rr_mode_get_height (mode);
-
-    if (w * h > best_w * best_h) {
-      best_w = w;
-      best_h = h;
-    }
-  }
-
-  if (best_w > 0 && best_h > 0) {
-    if (width)
-      *width = best_w;
-    if (height)
-      *height = best_h;
-
-    return TRUE;
-  }
-
-  return FALSE;
-}
-
-static gboolean
-output_info_supports_mode (CcDisplayPanel *self, GnomeRROutputInfo *info, int width, int height)
-{
-  GnomeRROutput *output;
-  GnomeRRMode **modes;
-  int i;
-
-  if (!gnome_rr_output_info_is_connected (info))
-    return FALSE;
-
-  output = gnome_rr_screen_get_output_by_name (self->priv->screen, gnome_rr_output_info_get_name (info));
-  if (!output)
-    return FALSE;
-
-  modes = gnome_rr_output_list_modes (output);
-
-  for (i = 0; modes[i]; i++) {
-    if (gnome_rr_mode_get_width (modes[i]) == width
-        && gnome_rr_mode_get_height (modes[i]) == height)
-      return TRUE;
-  }
-
-  return FALSE;
-}
-
-static void
-on_clone_changed (GtkWidget *box, gpointer data)
-{
-  CcDisplayPanel *self = data;
-
-  gnome_rr_config_set_clone (self->priv->current_configuration, gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (self->priv->clone_checkbox)));
-
-  if (gnome_rr_config_get_clone (self->priv->current_configuration))
-    {
-      int i;
-      int width, height;
-      GnomeRROutputInfo **outputs = gnome_rr_config_get_outputs (self->priv->current_configuration);
-
-      for (i = 0; outputs[i]; ++i)
-	{
-	  if (gnome_rr_output_info_is_connected (outputs[i]))
-	    {
-	      self->priv->current_output = outputs[i];
-	      break;
-	    }
-	}
-
-      /* Turn on all the connected screens that support the best clone mode.
-       * The user may hit "Mirror displays", but he shouldn't have to turn on
-       * all the required outputs as well.
-       */
-
-      get_clone_size (self->priv->screen, &width, &height);
-
-      for (i = 0; outputs[i]; i++) {
-	int x, y;
-	if (output_info_supports_mode (self, outputs[i], width, height)) {
-	  gnome_rr_output_info_set_active (outputs[i], TRUE);
-	  gnome_rr_output_info_get_geometry (outputs[i], &x, &y, NULL, NULL);
-	  gnome_rr_output_info_set_geometry (outputs[i], x, y, width, height);
-	}
-      }
-    }
-  else
-    {
-      if (output_overlaps (self->priv->current_output, self->priv->current_configuration))
-        lay_out_outputs_horizontally (self);
-    }
-
-  rebuild_gui (self);
-}
-
-static void
-apply_rotation_to_geometry (GnomeRROutputInfo *output, int *w, int *h)
-{
-  GnomeRRRotation rotation;
-
-  rotation = gnome_rr_output_info_get_rotation (output);
-  if ((rotation & GNOME_RR_ROTATION_90) || (rotation & GNOME_RR_ROTATION_270))
-    {
-      int tmp;
-      tmp = *h;
-      *h = *w;
-      *w = tmp;
-    }
-}
-
-static void
-get_geometry (GnomeRROutputInfo *output, int *w, int *h)
-{
-  if (gnome_rr_output_info_is_active (output))
-    {
-      gnome_rr_output_info_get_geometry (output, NULL, NULL, w, h);
-    }
-  else
-    {
-      *h = gnome_rr_output_info_get_preferred_height (output);
-      *w = gnome_rr_output_info_get_preferred_width (output);
-    }
-
-  apply_rotation_to_geometry (output, w, h);
-}
-
-#define SPACE 15
-#define MARGIN  15
-
-static GList *
-list_connected_outputs (CcDisplayPanel *self, int *total_w, int *total_h)
-{
-  int i, dummy;
-  GList *result = NULL;
-  GnomeRROutputInfo **outputs;
-
-  if (!total_w)
-    total_w = &dummy;
-  if (!total_h)
-    total_h = &dummy;
-
-  *total_w = 0;
-  *total_h = 0;
-
-  outputs = gnome_rr_config_get_outputs (self->priv->current_configuration);
-  for (i = 0; outputs[i] != NULL; ++i)
-    {
-      if (gnome_rr_output_info_is_connected (outputs[i]))
-	{
-	  int w, h;
-
-	  result = g_list_prepend (result, outputs[i]);
-
-	  get_geometry (outputs[i], &w, &h);
-
-          *total_w += w;
-          *total_h += h;
-        }
-    }
-
-  return g_list_reverse (result);
-}
-
-static int
-get_n_connected (CcDisplayPanel *self)
-{
-  GList *connected_outputs = list_connected_outputs (self, NULL, NULL);
-  int n = g_list_length (connected_outputs);
-
-  g_list_free (connected_outputs);
-
-  return n;
-}
-
-static double
-compute_scale (CcDisplayPanel *self)
-{
-  int available_w, available_h;
-  int total_w, total_h;
-  int n_monitors;
-  GdkRectangle viewport;
-  GList *connected_outputs;
-
-  foo_scroll_area_get_viewport (FOO_SCROLL_AREA (self->priv->area), &viewport);
-
-  connected_outputs = list_connected_outputs (self, &total_w, &total_h);
-
-  n_monitors = g_list_length (connected_outputs);
-
-  g_list_free (connected_outputs);
-
-  available_w = viewport.width - 2 * MARGIN - (n_monitors - 1) * SPACE;
-  available_h = viewport.height - 2 * MARGIN - (n_monitors - 1) * SPACE;
-
-  return MIN ((double)available_w / total_w, (double)available_h / total_h);
-}
-
-typedef struct Edge
-{
-  GnomeRROutputInfo *output;
-  int x1, y1;
-  int x2, y2;
-} Edge;
-
-typedef struct Snap
-{
-  Edge *snapper;              /* Edge that should be snapped */
-  Edge *snappee;
-  int dy, dx;
-} Snap;
-
-static void
-add_edge (GnomeRROutputInfo *output, int x1, int y1, int x2, int y2, GArray *edges)
-{
-  Edge e;
-
-  e.x1 = x1;
-  e.x2 = x2;
-  e.y1 = y1;
-  e.y2 = y2;
-  e.output = output;
-
-  g_array_append_val (edges, e);
-}
-
-static void
-list_edges_for_output (GnomeRROutputInfo *output, GArray *edges)
-{
-  int x, y, w, h;
-
-  gnome_rr_output_info_get_geometry (output, &x, &y, &w, &h);
-
-  apply_rotation_to_geometry (output, &w, &h);
-
-  /* Top, Bottom, Left, Right */
-  add_edge (output, x, y, x + w, y, edges);
-  add_edge (output, x, y + h, x + w, y + h, edges);
-  add_edge (output, x, y, x, y + h, edges);
-  add_edge (output, x + w, y, x + w, y + h, edges);
-}
-
-static void
-list_edges (GnomeRRConfig *config, GArray *edges)
-{
-  int i;
-  GnomeRROutputInfo **outputs = gnome_rr_config_get_outputs (config);
-
-  for (i = 0; outputs[i]; ++i)
-    {
-      if (gnome_rr_output_info_is_connected (outputs[i]))
-	list_edges_for_output (outputs[i], edges);
-    }
-}
-
-static gboolean
-overlap (int s1, int e1, int s2, int e2)
-{
-  return (!(e1 < s2 || s1 >= e2));
-}
-
-static gboolean
-horizontal_overlap (Edge *snapper, Edge *snappee)
-{
-  if (snapper->y1 != snapper->y2 || snappee->y1 != snappee->y2)
-    return FALSE;
-
-  return overlap (snapper->x1, snapper->x2, snappee->x1, snappee->x2);
-}
-
-static gboolean
-vertical_overlap (Edge *snapper, Edge *snappee)
-{
-  if (snapper->x1 != snapper->x2 || snappee->x1 != snappee->x2)
-    return FALSE;
-
-  return overlap (snapper->y1, snapper->y2, snappee->y1, snappee->y2);
-}
-
-static void
-add_snap (GArray *snaps, Snap snap)
-{
-  if (ABS (snap.dx) <= 200 || ABS (snap.dy) <= 200)
-    g_array_append_val (snaps, snap);
-}
-
-static void
-add_edge_snaps (Edge *snapper, Edge *snappee, GArray *snaps)
-{
-  Snap snap;
-
-  snap.snapper = snapper;
-  snap.snappee = snappee;
-
-  if (horizontal_overlap (snapper, snappee))
-    {
-      snap.dx = 0;
-      snap.dy = snappee->y1 - snapper->y1;
-
-      add_snap (snaps, snap);
-    }
-  else if (vertical_overlap (snapper, snappee))
-    {
-      snap.dy = 0;
-      snap.dx = snappee->x1 - snapper->x1;
-
-      add_snap (snaps, snap);
-    }
-
-  /* Corner snaps */
-  /* 1->1 */
-  snap.dx = snappee->x1 - snapper->x1;
-  snap.dy = snappee->y1 - snapper->y1;
-
-  add_snap (snaps, snap);
-
-  /* 1->2 */
-  snap.dx = snappee->x2 - snapper->x1;
-  snap.dy = snappee->y2 - snapper->y1;
-
-  add_snap (snaps, snap);
-
-  /* 2->2 */
-  snap.dx = snappee->x2 - snapper->x2;
-  snap.dy = snappee->y2 - snapper->y2;
-
-  add_snap (snaps, snap);
-
-  /* 2->1 */
-  snap.dx = snappee->x1 - snapper->x2;
-  snap.dy = snappee->y1 - snapper->y2;
-
-  add_snap (snaps, snap);
-}
-
-static void
-list_snaps (GnomeRROutputInfo *output, GArray *edges, GArray *snaps)
-{
-  int i;
-
-  for (i = 0; i < edges->len; ++i)
-    {
-      Edge *output_edge = &(g_array_index (edges, Edge, i));
-
-      if (output_edge->output == output)
-        {
-          int j;
-
-          for (j = 0; j < edges->len; ++j)
-            {
-              Edge *edge = &(g_array_index (edges, Edge, j));
-
-              if (edge->output != output)
-                add_edge_snaps (output_edge, edge, snaps);
-            }
-        }
-    }
-}
-
-#if 0
-static void
-print_edge (Edge *edge)
-{
-  g_debug ("(%d %d %d %d)", edge->x1, edge->y1, edge->x2, edge->y2);
-}
-#endif
-
-static gboolean
-corner_on_edge (int x, int y, Edge *e)
-{
-  if (x == e->x1 && x == e->x2 && y >= e->y1 && y <= e->y2)
-    return TRUE;
-
-  if (y == e->y1 && y == e->y2 && x >= e->x1 && x <= e->x2)
-    return TRUE;
-
-  return FALSE;
-}
-
-static gboolean
-edges_align (Edge *e1, Edge *e2)
-{
-  if (corner_on_edge (e1->x1, e1->y1, e2))
-    return TRUE;
-
-  if (corner_on_edge (e2->x1, e2->y1, e1))
-    return TRUE;
-
-  return FALSE;
-}
-
-static gboolean
-output_is_aligned (GnomeRROutputInfo *output, GArray *edges)
-{
-  gboolean result = FALSE;
-  int i;
-
-  for (i = 0; i < edges->len; ++i)
-    {
-      Edge *output_edge = &(g_array_index (edges, Edge, i));
-
-      if (output_edge->output == output)
-        {
-          int j;
-
-          for (j = 0; j < edges->len; ++j)
-            {
-              Edge *edge = &(g_array_index (edges, Edge, j));
-
-              /* We are aligned if an output edge matches
-               * an edge of another output
-               */
-              if (edge->output != output_edge->output)
-                {
-                  if (edges_align (output_edge, edge))
-                    {
-                      result = TRUE;
-                      goto done;
-                    }
-                }
-            }
-        }
-    }
- done:
-
-  return result;
-}
-
-static void
-get_output_rect (GnomeRROutputInfo *output, GdkRectangle *rect)
-{
-  gnome_rr_output_info_get_geometry (output, &rect->x, &rect->y, &rect->width, &rect->height);
-
-  apply_rotation_to_geometry (output, &rect->width, &rect->height);
-}
-
-static gboolean
-output_overlaps (GnomeRROutputInfo *output, GnomeRRConfig *config)
-{
-  int i;
-  GdkRectangle output_rect;
-  GnomeRROutputInfo **outputs;
-
-  g_assert (output != NULL);
-
-  get_output_rect (output, &output_rect);
-
-  outputs = gnome_rr_config_get_outputs (config);
-  for (i = 0; outputs[i]; ++i)
-    {
-      if (outputs[i] != output && gnome_rr_output_info_is_connected (outputs[i]))
-	{
-	  GdkRectangle other_rect;
-
-	  get_output_rect (outputs[i], &other_rect);
-	  if (gdk_rectangle_intersect (&output_rect, &other_rect, NULL))
-	    return TRUE;
-	}
-    }
-
-  return FALSE;
-}
-
-static gboolean
-gnome_rr_config_is_aligned (GnomeRRConfig *config, GArray *edges)
-{
-  int i;
-  gboolean result = TRUE;
-  GnomeRROutputInfo **outputs;
-
-  outputs = gnome_rr_config_get_outputs (config);
-  for (i = 0; outputs[i]; ++i)
-    {
-      if (gnome_rr_output_info_is_connected (outputs[i]))
-	{
-	  if (!output_is_aligned (outputs[i], edges))
-	    return FALSE;
-
-	  if (output_overlaps (outputs[i], config))
-	    return FALSE;
-	}
-    }
-
-  return result;
-}
-
-static gboolean
-is_corner_snap (const Snap *s)
-{
-  return s->dx != 0 && s->dy != 0;
-}
-
-static int
-compare_snaps (gconstpointer v1, gconstpointer v2)
-{
-  const Snap *s1 = v1;
-  const Snap *s2 = v2;
-  int sv1 = MAX (ABS (s1->dx), ABS (s1->dy));
-  int sv2 = MAX (ABS (s2->dx), ABS (s2->dy));
-  int d;
-
-  d = sv1 - sv2;
-
-  /* This snapping algorithm is good enough for rock'n'roll, but
-   * this is probably a better:
-   *
-   *    First do a horizontal/vertical snap, then
-   *    with the new coordinates from that snap,
-   *    do a corner snap.
-   *
-   * Right now, it's confusing that corner snapping
-   * depends on the distance in an axis that you can't actually see.
-   *
-   */
-  if (d == 0)
-    {
-      if (is_corner_snap (s1) && !is_corner_snap (s2))
-        return -1;
-      else if (is_corner_snap (s2) && !is_corner_snap (s1))
-        return 1;
-      else
-        return 0;
-    }
-  else
-    {
-      return d;
-    }
-}
-
-/* Sets a mouse cursor for a widget's window.  As a hack, you can pass
- * GDK_BLANK_CURSOR to mean "set the cursor to NULL" (i.e. reset the widget's
- * window's cursor to its default).
- */
-static void
-set_cursor (GtkWidget *widget, GdkCursorType type)
-{
-  GdkCursor *cursor;
-  GdkWindow *window;
-
-  if (type == GDK_BLANK_CURSOR)
-    cursor = NULL;
-  else
-    cursor = gdk_cursor_new_for_display (gtk_widget_get_display (widget), type);
-
-  window = gtk_widget_get_window (widget);
-
-  if (window)
-    gdk_window_set_cursor (window, cursor);
-
-  if (cursor)
-    g_object_unref (cursor);
-}
-
-static void
-set_top_bar_tooltip (CcDisplayPanel *self, gboolean is_dragging)
-{
-  const char *text;
-
-  if (is_dragging)
-    text = NULL;
-  else
-    text = _("Drag to change primary display.");
-
-  gtk_widget_set_tooltip_text (self->priv->area, text);
-}
-
-static void
-on_top_bar_event (FooScrollArea *area,
-                  FooScrollAreaEvent *event,
-                  CcDisplayPanel *self)
-{
-  /* Ignore drops */
-  if (event->type == FOO_DROP)
-    return;
-
-  /* If the mouse is inside the top bar, set the cursor to "you can move me".  See
-   * on_canvas_event() for where we reset the cursor to the default if it
-   * exits the outputs' area.
-   */
-  if (!gnome_rr_config_get_clone (self->priv->current_configuration) && get_n_connected (self) > 1)
-    set_cursor (GTK_WIDGET (area), GDK_HAND1);
-
-  if (event->type == FOO_BUTTON_PRESS)
-    {
-      rebuild_gui (self);
-      set_top_bar_tooltip (self, TRUE);
-
-      if (!gnome_rr_config_get_clone (self->priv->current_configuration) && get_n_connected (self) > 1)
-        {
-          self->priv->dragging_top_bar = TRUE;
-          foo_scroll_area_begin_grab (area, (FooScrollAreaEventFunc) on_top_bar_event, self);
-        }
-
-      foo_scroll_area_invalidate (area);
-    }
-  else
-    {
-      if (foo_scroll_area_is_grabbed (area))
-        {
-          if (event->type == FOO_BUTTON_RELEASE)
-            {
-              foo_scroll_area_end_grab (area, event);
-              self->priv->dragging_top_bar = FALSE;
-              set_top_bar_tooltip (self, FALSE);
-            }
-
-          foo_scroll_area_invalidate (area);
-        }
-    }
-}
-
-static void
-set_monitors_tooltip (CcDisplayPanel *self, gboolean is_dragging)
-{
-  const char *text;
-
-  if (is_dragging)
-    text = NULL;
-  else
-    text = _("Select a monitor to change its properties; drag it to rearrange its placement.");
-
-  gtk_widget_set_tooltip_text (self->priv->area, text);
-}
-
-static void
-set_primary_output (CcDisplayPanel *self,
-                    GnomeRROutputInfo *output)
-{
-  int i;
-  GnomeRROutputInfo **outputs;
-
-  outputs = gnome_rr_config_get_outputs (self->priv->current_configuration);
-  for (i = 0; outputs[i] != NULL; ++i)
-    gnome_rr_output_info_set_primary (outputs[i], outputs[i] == output);
-
-  gtk_widget_queue_draw (WID ("self->priv->area"));
-  /* refresh the combobox */
-  refresh_unity_launcher_placement (self);
-}
-
-static void
-on_output_event (FooScrollArea *area,
-                 FooScrollAreaEvent *event,
-                 gpointer data)
-{
-  GnomeRROutputInfo *output = data;
-  CcDisplayPanel *self = g_object_get_data (G_OBJECT (area), "panel");
-
-  if (event->type == FOO_DRAG_HOVER)
-    {
-      if (gnome_rr_output_info_is_active (output) && self->priv->dragging_top_bar)
-        set_primary_output (self, output);
-      return;
-    }
-  if (event->type == FOO_DROP)
-    {
-      /* Activate new primary? */
-      return;
-    }
-
-  /* If the mouse is inside the outputs, set the cursor to "you can move me".  See
-   * on_canvas_event() for where we reset the cursor to the default if it
-   * exits the outputs' area.
-   */
-  if (!gnome_rr_config_get_clone (self->priv->current_configuration) && get_n_connected (self) > 1)
-    set_cursor (GTK_WIDGET (area), GDK_FLEUR);
-
-  if (event->type == FOO_BUTTON_PRESS)
-    {
-      GrabInfo *info;
-
-      self->priv->current_output = output;
-
-      rebuild_gui (self);
-      set_monitors_tooltip (self, TRUE);
-
-      if (!gnome_rr_config_get_clone (self->priv->current_configuration) && get_n_connected (self) > 1)
-	{
-	  int output_x, output_y;
-	  gnome_rr_output_info_get_geometry (output, &output_x, &output_y, NULL, NULL);
-
-	  foo_scroll_area_begin_grab (area, on_output_event, data);
-
-	  info = g_new0 (GrabInfo, 1);
-	  info->grab_x = event->x;
-	  info->grab_y = event->y;
-	  info->output_x = output_x;
-	  info->output_y = output_y;
-
-	  g_object_set_data (G_OBJECT (output), "grab-info", info);
-	}
-      foo_scroll_area_invalidate (area);
-    }
-  else
-    {
-      if (foo_scroll_area_is_grabbed (area))
-	{
-	  GrabInfo *info = g_object_get_data (G_OBJECT (output), "grab-info");
-	  double scale = compute_scale (self);
-	  int old_x, old_y;
-	  int width, height;
-	  int new_x, new_y;
-	  int i;
-	  GArray *edges, *snaps, *new_edges;
-
-	  gnome_rr_output_info_get_geometry (output, &old_x, &old_y, &width, &height);
-	  new_x = info->output_x + (event->x - info->grab_x) / scale;
-	  new_y = info->output_y + (event->y - info->grab_y) / scale;
-
-	  gnome_rr_output_info_set_geometry (output, new_x, new_y, width, height);
-
-	  edges = g_array_new (TRUE, TRUE, sizeof (Edge));
-	  snaps = g_array_new (TRUE, TRUE, sizeof (Snap));
-	  new_edges = g_array_new (TRUE, TRUE, sizeof (Edge));
-
-	  list_edges (self->priv->current_configuration, edges);
-	  list_snaps (output, edges, snaps);
-
-	  g_array_sort (snaps, compare_snaps);
-
-	  gnome_rr_output_info_set_geometry (output, new_x, new_y, width, height);
-
-	  for (i = 0; i < snaps->len; ++i)
-	    {
-	      Snap *snap = &(g_array_index (snaps, Snap, i));
-	      GArray *new_edges = g_array_new (TRUE, TRUE, sizeof (Edge));
-
-	      gnome_rr_output_info_set_geometry (output, new_x + snap->dx, new_y + snap->dy, width, height);
-
-	      g_array_set_size (new_edges, 0);
-	      list_edges (self->priv->current_configuration, new_edges);
-
-	      if (gnome_rr_config_is_aligned (self->priv->current_configuration, new_edges))
-		{
-		  g_array_free (new_edges, TRUE);
-		  break;
-		}
-	      else
-		{
-		  gnome_rr_output_info_set_geometry (output, info->output_x, info->output_y, width, height);
-		}
-	    }
-
-	  g_array_free (new_edges, TRUE);
-	  g_array_free (snaps, TRUE);
-	  g_array_free (edges, TRUE);
-
-	  if (event->type == FOO_BUTTON_RELEASE)
-	    {
-	      foo_scroll_area_end_grab (area, event);
-	      set_monitors_tooltip (self, FALSE);
-
-	      g_free (g_object_get_data (G_OBJECT (output), "grab-info"));
-	      g_object_set_data (G_OBJECT (output), "grab-info", NULL);
-
-#if 0
-              g_debug ("new position: %d %d %d %d", output->x, output->y, output->width, output->height);
-#endif
-            }
-
-          foo_scroll_area_invalidate (area);
-        }
-    }
-}
-
-static void
-on_canvas_event (FooScrollArea *area,
-                 FooScrollAreaEvent *event,
-                 gpointer data)
-{
-  /* If the mouse exits the outputs, reset the cursor to the default.  See
-   * on_output_event() for where we set the cursor to the movement cursor if
-   * it is over one of the outputs.
-   */
-  set_cursor (GTK_WIDGET (area), GDK_BLANK_CURSOR);
-}
-
-static PangoLayout *
-get_display_name (CcDisplayPanel *self,
-		  GnomeRROutputInfo *output)
-{
-  PangoLayout *layout;
-  char *text;
-
-  if (gnome_rr_config_get_clone (self->priv->current_configuration))
-    text = mirror_monitor_name ();
-  else
-    text = g_strdup (gnome_rr_output_info_get_display_name (output));
-
-  layout = gtk_widget_create_pango_layout (GTK_WIDGET (self->priv->area), text);
-  g_free (text);
-  pango_layout_set_alignment (layout, PANGO_ALIGN_CENTER);
-
-  return layout;
-}
-
-static void
-paint_background (FooScrollArea *area,
-                  cairo_t       *cr)
-{
-  GdkRectangle viewport;
-  GtkWidget *widget;
-  GtkStyleContext *context;
-  GdkRGBA fg, bg;
-
-  widget = GTK_WIDGET (area);
-
-  foo_scroll_area_get_viewport (area, &viewport);
-  context = gtk_widget_get_style_context (widget);
-  gtk_style_context_get_color (context, GTK_STATE_FLAG_NORMAL, &fg);
-  gtk_style_context_get_background_color (context, GTK_STATE_FLAG_NORMAL, &bg);
-
-  cairo_set_source_rgba (cr,
-                         (fg.red + bg.red) / 2,
-                         (fg.green + bg.green) / 2,
-                         (fg.blue + bg.blue) / 2,
-                         (fg.alpha + bg.alpha) / 2);
-
-  cairo_rectangle (cr,
-                   viewport.x, viewport.y,
-                   viewport.width, viewport.height);
-
-  cairo_fill_preserve (cr);
-
-  foo_scroll_area_add_input_from_fill (area, cr, on_canvas_event, NULL);
-
-  cairo_set_source_rgba (cr,
-                         0.7 * bg.red,
-                         0.7 * bg.green,
-                         0.7 * bg.blue,
-                         0.7 * bg.alpha);
-
-  cairo_stroke (cr);
-}
-
-static void
-color_shade (double *r,
-             double *g,
-             double *b,
-             double  k)
-{
-  double h, s, v;
-
-  gtk_rgb_to_hsv (*r, *g, *b, &h, &s, &v);
-
-  s *= k;
-  if (s > 1.0)
-    s = 1.0;
-  else if (s < 0.0)
-    s = 0.0;
-
-  v *= k;
-  if (v > 1.0)
-    v = 1.0;
-  else if (v < 0.0)
-    v = 0.0;
-
-  gtk_hsv_to_rgb (h, s, v, r, g, b);
-}
-
-static void
-paint_output (CcDisplayPanel *self, cairo_t *cr, int i)
-{
-  int w, h;
-  double scale = compute_scale (self);
-  double x, y;
-  int output_x, output_y;
-  GnomeRRRotation rotation;
-  int total_w, total_h;
-  GList *connected_outputs = list_connected_outputs (self, &total_w, &total_h);
-  GnomeRROutputInfo *output = g_list_nth (connected_outputs, i)->data;
-  PangoLayout *layout = get_display_name (self, output);
-  PangoRectangle ink_extent, log_extent;
-  GdkRectangle viewport;
-  GdkRGBA output_color;
-  double r, g, b;
-  double available_w;
-  double factor;
-
-  cairo_save (cr);
-
-  foo_scroll_area_get_viewport (FOO_SCROLL_AREA (self->priv->area), &viewport);
-  get_geometry (output, &w, &h);
-
-#if 0
-  g_debug ("%s (%p) geometry %d %d %d primary=%d", output->name, output->name,
-           w, h, output->rate, output->primary);
-#endif
-
-  viewport.height -= 2 * MARGIN;
-  viewport.width -= 2 * MARGIN;
-
-  gnome_rr_output_info_get_geometry (output, &output_x, &output_y, NULL, NULL);
-  x = output_x * scale + MARGIN + (viewport.width - total_w * scale) / 2.0;
-  y = output_y * scale + MARGIN + (viewport.height - total_h * scale) / 2.0;
-
-#if 0
-  g_debug ("scaled: %f %f", x, y);
-
-  g_debug ("scale: %f", scale);
-
-  g_debug ("%f %f %f %f", x, y, w * scale + 0.5, h * scale + 0.5);
-#endif
-
-  cairo_translate (cr,
-                   x + (w * scale + 0.5) / 2,
-                   y + (h * scale + 0.5) / 2);
-
-  /* rotation is already applied in get_geometry */
-
-  rotation = gnome_rr_output_info_get_rotation (output);
-  if (rotation & GNOME_RR_REFLECT_X)
-    cairo_scale (cr, -1, 1);
-
-  if (rotation & GNOME_RR_REFLECT_Y)
-    cairo_scale (cr, 1, -1);
-
-  cairo_translate (cr,
-                   - x - (w * scale + 0.5) / 2,
-                   - y - (h * scale + 0.5) / 2);
-
-  if (output == self->priv->current_output)
-    {
-      GtkStyleContext *context;
-      GdkRGBA color;
-
-      context = gtk_widget_get_style_context (self->priv->area);
-      gtk_style_context_get_background_color (context, GTK_STATE_FLAG_SELECTED, &color);
-
-      cairo_rectangle (cr, x - 2, y - 2, w * scale + 0.5 + 4, h * scale + 0.5 + 4);
-
-      cairo_set_line_width (cr, 4);
-      cairo_set_source_rgba (cr, color.red, color.green, color.blue, 0.5);
-      cairo_stroke (cr);
-    }
-
-  cairo_rectangle (cr, x, y, w * scale + 0.5, h * scale + 0.5);
-  cairo_clip_preserve (cr);
-
-  cc_rr_labeler_get_rgba_for_output (self->priv->labeler, output, &output_color);
-  r = output_color.red;
-  g = output_color.green;
-  b = output_color.blue;
-
-  if (!gnome_rr_output_info_is_active (output))
-    {
-      /* If the output is turned off, just darken the selected color */
-      color_shade (&r, &g, &b, 0.4);
-    }
-
-  cairo_set_source_rgba (cr, r, g, b, 1.0);
-
-  foo_scroll_area_add_input_from_fill (FOO_SCROLL_AREA (self->priv->area),
-                                       cr, on_output_event, output);
-  cairo_fill (cr);
-
-  cairo_rectangle (cr, x + 0.5, y + 0.5, w * scale + 0.5 - 1, h * scale + 0.5 - 1);
-
-  cairo_set_line_width (cr, 1);
-  cairo_set_source_rgba (cr, 0.0, 0.0, 0.0, 1.0);
-
-  cairo_stroke (cr);
-  cairo_set_line_width (cr, 2);
-
-  cairo_save (cr);
-
-  layout_set_font (layout, "Sans 10");
-  pango_layout_get_pixel_extents (layout, &ink_extent, &log_extent);
-
-  available_w = w * scale + 0.5 - 6; /* Same as the inner rectangle's width, minus 1 pixel of padding on each side */
-  if (available_w < ink_extent.width)
-    factor = available_w / ink_extent.width;
-  else
-    factor = 1.0;
-
-  cairo_move_to (cr,
-                 x + ((w * scale + 0.5) - factor * log_extent.width) / 2,
-                 y + ((h * scale + 0.5) - factor * log_extent.height) / 2);
-
-  cairo_scale (cr, factor, factor);
-  if (gnome_rr_output_info_is_active (output))
-    cairo_set_source_rgb (cr, 0.0, 0.0, 0.0);
-  else
-    cairo_set_source_rgb (cr, 1.0, 1.0, 1.0);
-
-  pango_cairo_show_layout (cr, layout);
-  g_object_unref (layout);
-  cairo_restore (cr);
-
-  /* Only display a launcher on all or primary monitor */
-  if (is_unity_session ())
-    {
-      if (gnome_rr_output_info_is_active (output) && (unity_launcher_on_all_monitors (self->priv->unity_settings) || gnome_rr_output_info_get_primary (output)))
-        {
-          cairo_rectangle (cr, x, y, 10, h * scale + 0.5);
-          cairo_set_source_rgb (cr, 0, 0, 0);
-          foo_scroll_area_add_input_from_fill (FOO_SCROLL_AREA (self->priv->area),
-                                               cr,
-                                               (FooScrollAreaEventFunc) on_top_bar_event,
-                                               self);
-          cairo_fill (cr);
-
-          cairo_set_source_rgb (cr, 0.25, 0.25, 0.25);
-          cairo_rectangle (cr, x + 1, y + 6, 8, 8);
-          cairo_rectangle (cr, x + 1, y + 16, 8, 8);
-          cairo_rectangle (cr, x + 1, y + 26, 8, 8);
-          cairo_rectangle (cr, x + 1, y + 36, 8, 8);
-          cairo_rectangle (cr, x + 1, y + h * scale + 0.5 - 10, 8, 8);
-          cairo_fill (cr);
-        }
-    }
-
-  if (gnome_rr_output_info_get_primary (output) && !is_unity_session ())
-    {
-      const char *clock_format;
-      char *text;
-      gboolean use_24;
-      GDateTime *dt;
-      GDesktopClockFormat value;
-
-      /* top bar */
-      cairo_rectangle (cr, x, y, w * scale + 0.5, TOP_BAR_HEIGHT);
-      cairo_set_source_rgb (cr, 0, 0, 0);
-      foo_scroll_area_add_input_from_fill (FOO_SCROLL_AREA (self->priv->area),
-                                           cr,
-                                           (FooScrollAreaEventFunc) on_top_bar_event,
-                                           self);
-
-      cairo_fill (cr);
-
-      /* clock */
-      value = g_settings_get_enum (self->priv->clock_settings, CLOCK_FORMAT_KEY);
-      use_24 = value == G_DESKTOP_CLOCK_FORMAT_24H;
-      if (use_24)
-        clock_format = _("%a %R");
-      else
-        clock_format = _("%a %l:%M %p");
-
-      dt = g_date_time_new_now_local ();
-      text = g_date_time_format (dt, clock_format);
-      g_date_time_unref (dt);
-
-      layout = gtk_widget_create_pango_layout (GTK_WIDGET (self->priv->area), text);
-      g_free (text);
-      pango_layout_set_alignment (layout, PANGO_ALIGN_CENTER);
-
-      layout_set_font (layout, "Sans 4");
-      pango_layout_get_pixel_extents (layout, &ink_extent, &log_extent);
-
-      if (available_w < ink_extent.width)
-        factor = available_w / ink_extent.width;
-      else
-        factor = 1.0;
-
-      cairo_move_to (cr,
-                     x + ((w * scale + 0.5) - factor * log_extent.width) / 2,
-                     y + (TOP_BAR_HEIGHT - factor * log_extent.height) / 2);
-
-      cairo_scale (cr, factor, factor);
-
-      cairo_set_source_rgb (cr, 1.0, 1.0, 1.0);
-
-      pango_cairo_show_layout (cr, layout);
-      g_object_unref (layout);
-    }
-
-  cairo_restore (cr);
-}
-
-static void
-on_area_paint (FooScrollArea  *area,
-               cairo_t        *cr,
-               gpointer        data)
-{
-  CcDisplayPanel *self = data;
-  GList *connected_outputs = NULL;
-  GList *list;
-
-  paint_background (area, cr);
-
-  if (!self->priv->current_configuration)
-    return;
-
-  connected_outputs = list_connected_outputs (self, NULL, NULL);
-
-  for (list = connected_outputs; list != NULL; list = list->next)
-    {
-      paint_output (self, cr, g_list_position (connected_outputs, list));
-
-      if (gnome_rr_config_get_clone (self->priv->current_configuration))
-	break;
-    }
-}
-
-static void
-make_text_combo (GtkWidget *widget, int sort_column)
-{
-  GtkComboBox *box = GTK_COMBO_BOX (widget);
-  GtkListStore *store = gtk_list_store_new (
-                                            NUM_COLS,
-                                            G_TYPE_STRING,          /* Text */
-                                            G_TYPE_INT,             /* Width */
-                                            G_TYPE_INT,             /* Height */
-                                            G_TYPE_INT,             /* Frequency */
-                                            G_TYPE_INT,             /* Width * Height */
-                                            G_TYPE_INT);            /* Rotation */
-
-  GtkCellRenderer *cell;
-
-  gtk_cell_layout_clear (GTK_CELL_LAYOUT (widget));
-
-  gtk_combo_box_set_model (box, GTK_TREE_MODEL (store));
-
-  cell = gtk_cell_renderer_text_new ();
-  gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (box), cell, TRUE);
-  gtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (box), cell,
-                                  "text", 0,
-                                  NULL);
-
-  if (sort_column != -1)
-    {
-      gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (store),
-                                            sort_column,
-                                            GTK_SORT_DESCENDING);
-    }
-}
-
-static void
-compute_virtual_size_for_configuration (GnomeRRConfig *config, int *ret_width, int *ret_height)
-{
-  int i;
-  int width, height;
-  int output_x, output_y, output_width, output_height;
-  GnomeRROutputInfo **outputs;
-
-  width = height = 0;
-
-  outputs = gnome_rr_config_get_outputs (config);
-  for (i = 0; outputs[i] != NULL; i++)
-    {
-      if (gnome_rr_output_info_is_active (outputs[i]))
-	{
-	  gnome_rr_output_info_get_geometry (outputs[i], &output_x, &output_y, &output_width, &output_height);
-	  width = MAX (width, output_x + output_width);
-	  height = MAX (height, output_y + output_height);
-	}
-    }
-
-  *ret_width = width;
-  *ret_height = height;
-}
-
-static void
-check_required_virtual_size (CcDisplayPanel *self)
-{
-  int req_width, req_height;
-  int min_width, max_width;
-  int min_height, max_height;
-
-  compute_virtual_size_for_configuration (self->priv->current_configuration, &req_width, &req_height);
-
-  gnome_rr_screen_get_ranges (self->priv->screen, &min_width, &max_width, &min_height, &max_height);
-
-#if 0
-  g_debug ("X Server supports:");
-  g_debug ("min_width = %d, max_width = %d", min_width, max_width);
-  g_debug ("min_height = %d, max_height = %d", min_height, max_height);
-
-  g_debug ("Requesting size of %dx%d", req_width, req_height);
-#endif
-
-  if (!(min_width <= req_width && req_width <= max_width
-        && min_height <= req_height && req_height <= max_height))
-    {
-      /* FIXME: present a useful dialog, maybe even before the user tries to Apply */
-#if 0
-      g_debug ("Your X server needs a larger Virtual size!");
-#endif
-    }
-}
-
-static void
-begin_version2_apply_configuration (CcDisplayPanel *self, GdkWindow *parent_window, guint32 timestamp)
-{
-  XID parent_window_xid;
-  GError *error = NULL;
-
-  parent_window_xid = GDK_WINDOW_XID (parent_window);
-
-  self->priv->proxy = g_dbus_proxy_new_for_bus_sync (G_BUS_TYPE_SESSION,
-                                                     G_DBUS_PROXY_FLAGS_NONE,
-                                                     NULL,
-                                                     "org.gnome.SettingsDaemon",
-                                                     "/org/gnome/SettingsDaemon/XRANDR",
-                                                     "org.gnome.SettingsDaemon.XRANDR_2",
-                                                     NULL,
-                                                     &error);
-  if (self->priv->proxy == NULL) {
-    error_message (self, _("Failed to apply configuration: %s"), error->message);
-    g_error_free (error);
-    return;
-  }
-
-  g_dbus_proxy_call (self->priv->proxy,
-                     "ApplyConfiguration",
-                     g_variant_new ("(xx)", (gint64) parent_window_xid, (gint64) timestamp),
-                     G_DBUS_CALL_FLAGS_NONE,
-                     -1,
-                     NULL,
-                     apply_configuration_returned_cb,
-                     self);
-}
-
-static void
-ensure_current_configuration_is_saved (void)
-{
-  GnomeRRScreen *rr_screen;
-  GnomeRRConfig *rr_config;
-
-  /* Normally, gnome_rr_config_save() creates a backup file based on the
-   * old monitors.xml.  However, if *that* file didn't exist, there is
-   * nothing from which to create a backup.  So, here we'll save the
-   * current/unchanged configuration and then let our caller call
-   * gnome_rr_config_save() again with the new/changed configuration, so
-   * that there *will* be a backup file in the end.
-   */
-
-  rr_screen = gnome_rr_screen_new (gdk_screen_get_default (), NULL); /* NULL-GError */
-  if (!rr_screen)
-    return;
-
-  rr_config = gnome_rr_config_new_current (rr_screen, NULL);
-  gnome_rr_config_ensure_primary (rr_config);
-  gnome_rr_config_save (rr_config, NULL); /* NULL-GError */
-
-  g_object_unref (rr_config);
-  g_object_unref (rr_screen);
-}
-
-static void
-apply_configuration_returned_cb (GObject          *proxy,
-                                 GAsyncResult     *res,
-                                 gpointer          data)
-{
-  CcDisplayPanel *self = data;
-  GVariant *result;
-  GError *error = NULL;
-
-  result = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, &error);
-  if (error)
-    error_message (self, _("Failed to apply configuration: %s"), error->message);
-  g_clear_error (&error);  
-  if (result)
-    g_variant_unref (result);
-
-  g_object_unref (self->priv->proxy);
-  self->priv->proxy = NULL;
-
-  gtk_widget_set_sensitive (self->priv->panel, TRUE);
-}
-
-static gboolean
-sanitize_and_save_configuration (CcDisplayPanel *self)
-{
-  GError *error;
-
-  gnome_rr_config_sanitize (self->priv->current_configuration);
-  gnome_rr_config_ensure_primary (self->priv->current_configuration);
-
-  check_required_virtual_size (self);
-
-  foo_scroll_area_invalidate (FOO_SCROLL_AREA (self->priv->area));
-
-  ensure_current_configuration_is_saved ();
-
-  error = NULL;
-  if (!gnome_rr_config_save (self->priv->current_configuration, &error))
-    {
-      error_message (self, _("Could not save the monitor configuration"), error->message);
-      g_error_free (error);
-      return FALSE;
-    }
-
-  return TRUE;
-}
-
-static void
-apply (CcDisplayPanel *self)
-{
-  GdkWindow *window;
-
-  self->priv->apply_button_clicked_timestamp = gtk_get_current_event_time ();
-
-  if (!sanitize_and_save_configuration (self))
-    return;
-
-  g_assert (self->priv->proxy == NULL);
-
-  gtk_widget_set_sensitive (self->priv->panel, FALSE);
-
-  window = gtk_widget_get_window (gtk_widget_get_toplevel (self->priv->panel));
-
-  begin_version2_apply_configuration (self, window,
-                                      self->priv->apply_button_clicked_timestamp);
-}
-
-#if 0
-/* Returns whether the graphics driver doesn't advertise RANDR 1.2 features, and just 1.0 */
-static gboolean
-driver_is_randr_10 (GnomeRRConfig *config)
-{
-  /* In the Xorg code, see xserver/randr/rrinfo.c:RRScanOldConfig().  It gets
-   * called when the graphics driver doesn't support RANDR 1.2 yet, just 1.0.
-   * In that case, the X server's base code (which supports RANDR 1.2) will
-   * simulate having a single output called "default".  For drivers that *do*
-   * support RANDR 1.2, the separate outputs will be named differently, we
-   * hope.
-   *
-   * This heuristic is courtesy of Dirk Mueller <dmueller@suse.de>
-   *
-   * FIXME: however, we don't even check for XRRQueryVersion() returning 1.2, neither
-   * here nor in gnome-desktop/libgnomedesktop*.c.  Do we need to check for that,
-   * or is gnome_rr_screen_new()'s return value sufficient?
-   */
-
-  return (count_all_outputs (config) == 1 && strcmp (gnome_rr_output_info_get_name (gnome_rr_config_get_outputs (config)[0]), "default") == 0);
-}
-#endif
-
-static void
-on_detect_displays (GtkWidget *widget, gpointer data)
-{
-  CcDisplayPanel *self = data;
-  GError *error;
-
-  error = NULL;
-  if (!gnome_rr_screen_refresh (self->priv->screen, &error)) {
-    if (error) {
-      error_message (self, _("Could not detect displays"), error->message);
-      g_error_free (error);
-    }
-  }
-}
-
-static GnomeRROutputInfo *
-get_nearest_output (GnomeRRConfig *configuration, int x, int y)
-{
-  int i;
-  int nearest_index;
-  int nearest_dist;
-  GnomeRROutputInfo **outputs;
-
-  nearest_index = -1;
-  nearest_dist = G_MAXINT;
-
-  outputs = gnome_rr_config_get_outputs (configuration);
-  for (i = 0; outputs[i] != NULL; i++)
-    {
-      int dist_x, dist_y;
-      int output_x, output_y, output_width, output_height;
-
-      if (!(gnome_rr_output_info_is_connected (outputs[i]) && gnome_rr_output_info_is_active (outputs[i])))
-	continue;
-
-      gnome_rr_output_info_get_geometry (outputs[i], &output_x, &output_y, &output_width, &output_height);
-
-      if (x < output_x)
-	dist_x = output_x - x;
-      else if (x >= output_x + output_width)
-	dist_x = x - (output_x + output_width) + 1;
-      else
-	dist_x = 0;
-
-      if (y < output_y)
-	dist_y = output_y - y;
-      else if (y >= output_y + output_height)
-	dist_y = y - (output_y + output_height) + 1;
-      else
-	dist_y = 0;
-
-      if (MIN (dist_x, dist_y) < nearest_dist)
-	{
-	  nearest_dist = MIN (dist_x, dist_y);
-	  nearest_index = i;
-	}
-    }
-
-  if (nearest_index != -1)
-    return outputs[nearest_index];
-  else
-    return NULL;
-}
-
-/* Gets the output that contains the largest intersection with the window.
- * Logic stolen from gdk_screen_get_monitor_at_window().
- */
-static GnomeRROutputInfo *
-get_output_for_window (GnomeRRConfig *configuration, GdkWindow *window)
-{
-  GdkRectangle win_rect;
-  int i;
-  int largest_area;
-  int largest_index;
-  GnomeRROutputInfo **outputs;
-
-  gdk_window_get_geometry (window, &win_rect.x, &win_rect.y, &win_rect.width, &win_rect.height);
-  gdk_window_get_origin (window, &win_rect.x, &win_rect.y);
-
-  largest_area = 0;
-  largest_index = -1;
-
-  outputs = gnome_rr_config_get_outputs (configuration);
-  for (i = 0; outputs[i] != NULL; i++)
-    {
-      GdkRectangle output_rect, intersection;
-
-      gnome_rr_output_info_get_geometry (outputs[i], &output_rect.x, &output_rect.y, &output_rect.width, &output_rect.height);
-
-      if (gnome_rr_output_info_is_connected (outputs[i]) && gdk_rectangle_intersect (&win_rect, &output_rect, &intersection))
-	{
-	  int area;
-
-	  area = intersection.width * intersection.height;
-	  if (area > largest_area)
-	    {
-	      largest_area = area;
-	      largest_index = i;
-	    }
-	}
-    }
-
-  if (largest_index != -1)
-    return outputs[largest_index];
-  else
-    return get_nearest_output (configuration,
-			       win_rect.x + win_rect.width / 2,
-			       win_rect.y + win_rect.height / 2);
-}
-
-static void
-dialog_toplevel_focus_changed (GtkWindow      *window,
-			       GParamSpec     *pspec,
-			       CcDisplayPanel *self)
-{
-  if (self->priv->labeler == NULL)
-    return;
-  if (gtk_window_has_toplevel_focus (window))
-    cc_rr_labeler_show (self->priv->labeler);
-  else
-    cc_rr_labeler_hide (self->priv->labeler);
-}
-
-static void
-on_toplevel_realized (GtkWidget     *widget,
-                      CcDisplayPanel *self)
-{
-  self->priv->current_output = get_output_for_window (self->priv->current_configuration,
-                                               gtk_widget_get_window (widget));
-  rebuild_gui (self);
-}
-
-/* We select the current output, i.e. select the one being edited, based on
- * which output is showing the configuration dialog.
- */
-static void
-select_current_output_from_dialog_position (CcDisplayPanel *self)
-{
-  GtkWidget *toplevel;
-
-  toplevel = gtk_widget_get_toplevel (self->priv->panel);
-
-  if (gtk_widget_get_realized (toplevel)) {
-    self->priv->current_output = get_output_for_window (self->priv->current_configuration,
-                                                 gtk_widget_get_window (toplevel));
-    rebuild_gui (self);
-  } else {
-    g_signal_connect (toplevel, "realize", G_CALLBACK (on_toplevel_realized), self);
-    self->priv->current_output = NULL;
-  }
-}
-
-/* This is a GtkWidget::map-event handler.  We wait for the display-properties
- * dialog to be mapped, and then we select the output which corresponds to the
- * monitor on which the dialog is being shown.
- */
-static gboolean
-dialog_map_event_cb (GtkWidget *widget, GdkEventAny *event, gpointer data)
-{
-  CcDisplayPanel *self = data;
-
-  select_current_output_from_dialog_position (self);
-  return FALSE;
-}
-
-static void
-stickyedge_widget_refresh (GtkSwitch *switcher, GSettings *settings)
-{
-  gboolean stickyedge_enabled = g_settings_get_boolean (settings, UNITY_STICKY_EDGE_KEY);
-
-  gtk_switch_set_active (switcher, stickyedge_enabled);
-}
-
-static void
-ext_stickyedge_changed_callback (GSettings* settings,
-                                 guint key,
-                                 gpointer user_data)
-{
-  stickyedge_widget_refresh (GTK_SWITCH (user_data), settings);
-}
-
-static void
-on_stickyedge_changed (GtkSwitch *switcher, GParamSpec *pspec, gpointer user_data)
-{
-  CcDisplayPanel *self = CC_DISPLAY_PANEL (user_data);
-  gboolean enabled = gtk_switch_get_active (GTK_SWITCH (switcher));
-
-  /* 3d */
-  g_settings_set_boolean (self->priv->unity_settings, UNITY_STICKY_EDGE_KEY, enabled);
-  /* 2d */
-  if (self->priv->unity2d_settings_main)
-    g_settings_set_boolean (self->priv->unity2d_settings_main, "sticky-edges", enabled);
-}
-
-static gboolean
-unity_launcher_on_all_monitors (GSettings *settings)
-{
-  gint value = g_settings_get_int (settings, UNITY_LAUNCHER_ALL_MONITORS_KEY);
-  return (value == 0);
-}
-
-static GdkPixbuf*
-get_monitor_pixbuf (CcDisplayPanel *self, GnomeRROutputInfo *output)
-{
-  GdkRGBA color;
-  cairo_surface_t *cairo_surface;
-  cairo_t *cr;
-  int monitor_width = 30;
-  int monitor_height = 15;
-
-  cc_rr_labeler_get_rgba_for_output (self->priv->labeler, output, &color);
-
-  cairo_surface = cairo_image_surface_create (CAIRO_FORMAT_RGB24, monitor_width, monitor_height);
-  cr = cairo_create (cairo_surface);
-  cairo_surface_destroy (cairo_surface);
-  cairo_set_operator (cr, CAIRO_OPERATOR_CLEAR);
-  cairo_paint (cr);
-
-  cairo_set_operator (cr, CAIRO_OPERATOR_OVER);
-  cairo_set_source_rgb (cr, color.red, color.green, color.blue);
-  cairo_rectangle (cr, 0.5, 0.5, monitor_width - 1, monitor_height - 1);
-  cairo_fill (cr);
-
-  cairo_set_line_width (cr, 1);
-  cairo_set_source_rgba (cr, 0, 0, 0, 1.0);
-  cairo_rectangle (cr, 0.5, 0.5, monitor_width - 1, monitor_height - 1);
-  cairo_stroke (cr);
-
-  return gdk_pixbuf_get_from_surface (cairo_get_target (cr), 0, 0, monitor_width, monitor_height);
-}
-
-static void
-refresh_unity_launcher_placement (CcDisplayPanel *self)
-{
-  GtkWidget *launcher_placement_combo = WID ("launcher_placement_combo");
-  GtkListStore *liststore;
-  GtkTreeIter iter;
-  GList *connected_outputs = NULL;
-  GList *list;
-  gboolean launcher_on_all_monitors = unity_launcher_on_all_monitors (self->priv->unity_settings);
-  gint index_of_primary_screen = 0;
-  gint i;
-
-  liststore = (GtkListStore *) gtk_builder_get_object (self->priv->builder, "available_launcher_placement_store");
-  gtk_list_store_clear (liststore);
-
-  connected_outputs = list_connected_outputs (self, NULL, NULL);
-  for (list = connected_outputs, i = 0; list != NULL; list = list->next)
-    {
-      char *monitor_name;
-      GdkPixbuf *monitor_pixbuf;
-      GnomeRROutputInfo *output = list->data;
-
-      if (!gnome_rr_output_info_is_active (output))
-        continue;
-
-      gtk_list_store_append (liststore, &iter);
-      monitor_name = g_strdup (gnome_rr_output_info_get_display_name (output));
-      monitor_pixbuf = get_monitor_pixbuf (self, output);
-
-      gtk_list_store_set (liststore, &iter, 0, monitor_pixbuf, 1, monitor_name, -1);
-
-      /* select it if primary and only one launcher */
-      if (gnome_rr_output_info_get_primary (output) && (!launcher_on_all_monitors))
-        index_of_primary_screen = i;
-      i++;
-
-      g_object_unref (monitor_pixbuf);
-      g_free (monitor_name);
-    }
-
-   // FIXME: check autosort?
-   gtk_list_store_append (liststore, &iter);
-   gtk_list_store_set (liststore, &iter, 0, NULL, 1, _("All displays"), -1);
-
-   if (launcher_on_all_monitors)
-     index_of_primary_screen = i;
-
-   gtk_combo_box_set_active (GTK_COMBO_BOX (launcher_placement_combo), index_of_primary_screen);
-}
-
-static void
-refresh_unity_monitor_scale (CcDisplayPanel *self)
-{
-  GtkWidget *ui_scale_monitor_combo = WID ("ui_scale_monitor_combo");
-  GtkListStore *liststore;
-  GtkTreeIter iter;
-  GList *connected_outputs = NULL;
-  GList *list;
-  gchar *target_monitor = g_settings_get_string (self->priv->unity_ui_settings, UNITY_UI_SCALE_FACTOR_MONITOR);
-  gint target_monitor_idx = -1;
-  gint i;
-
-  liststore = (GtkListStore *) gtk_builder_get_object (self->priv->builder, "available_ui_scale_monitor_store");
-  gtk_list_store_clear (liststore);
-
-  connected_outputs = list_connected_outputs (self, NULL, NULL);
-  for (list = connected_outputs, i = 0; list != NULL; list = list->next)
-    {
-      gchar *monitor_name;
-      GdkPixbuf *monitor_pixbuf;
-      GnomeRROutputInfo *output = list->data;
-
-      if (!gnome_rr_output_info_is_active (output))
-        continue;
-
-      gtk_list_store_append (liststore, &iter);
-      monitor_name = g_strdup (gnome_rr_output_info_get_display_name (output));
-      monitor_pixbuf = get_monitor_pixbuf (self, output);
-
-      gtk_list_store_set (liststore, &iter, 0, monitor_pixbuf, 1, monitor_name, -1);
-
-      /* select it if primary and only one launcher */
-      if (g_strcmp0 (gnome_rr_output_info_get_name (output), target_monitor) == 0)
-        target_monitor_idx = i;
-      i++;
-
-      g_object_unref (monitor_pixbuf);
-      g_free (monitor_name);
-    }
-
-   gtk_list_store_append (liststore, &iter);
-   gtk_list_store_set (liststore, &iter, 0, NULL, 1, _("Display with largest controls"), -1);
-   gint max_idx = i++;
-
-   gtk_list_store_append (liststore, &iter);
-   gtk_list_store_set (liststore, &iter, 0, NULL, 1, _("Display with smallest controls"), -1);
-   gint min_idx = i++;
-
-   if (target_monitor_idx < 0)
-    {
-      gboolean fallback_max_scale = g_settings_get_boolean (self->priv->unity_ui_settings, UNITY_UI_SCALE_FALLBACK_TO_MAX);
-      target_monitor_idx = fallback_max_scale ? max_idx : min_idx;
-    }
-
-   gtk_combo_box_set_active (GTK_COMBO_BOX (ui_scale_monitor_combo), target_monitor_idx);
-
-   g_free (target_monitor);
-}
-
-static gboolean
-switcher_set_to_launcher_on_all_monitors (CcDisplayPanel *self)
-{
-  GtkComboBox *combo = GTK_COMBO_BOX (WID ("launcher_placement_combo"));
-  gint active = gtk_combo_box_get_active (combo);
-  gint number_items = gtk_tree_model_iter_n_children (gtk_combo_box_get_model (combo),
-                                                      NULL);
-  return (active == number_items - 1);
-}
-
-static void
-ext_launcher_placement_changed_callback (GSettings* settings,
-                                         guint key,
-                                         gpointer user_data)
-{
-  // add some crazyness as 2d/3d are not using the same keys
-  CcDisplayPanel *self = CC_DISPLAY_PANEL (user_data);
-  gint launcher_unity_value = 0;
-
-  // two options support: all monitors (0)i or just primary desktop (hence set to 1, not any other number)
-  if (! switcher_set_to_launcher_on_all_monitors (self))
-    launcher_unity_value = 1;
-
-  if (g_settings_get_int (settings, UNITY_LAUNCHER_ALL_MONITORS_KEY) != launcher_unity_value)
-    refresh_unity_launcher_placement (self);
-}
-
-static void
-on_launcher_placement_combo_changed (GtkComboBox *combo, CcDisplayPanel *self)
-{
-  gint active = gtk_combo_box_get_active (combo);
-  gint i;
-  gint index_on_combo = 0;
-
-  if (active < 0)
-    return;
-  gint value = 0;
-  gboolean on_all_monitors = switcher_set_to_launcher_on_all_monitors (self);
-
-  if (!on_all_monitors) {
-    value = 1;
-    // set the primary output if needed
-    GnomeRROutputInfo **outputs = gnome_rr_config_get_outputs (self->priv->current_configuration);
-
-    for (i = 0; outputs[i] != NULL; ++i)
-      {
-        GnomeRROutputInfo *output = outputs[i];
-        if (!gnome_rr_output_info_is_active (output))
-          continue;
-
-        if ((active == index_on_combo) && !gnome_rr_output_info_get_primary (output))
-          {
-            set_primary_output (self, output);
-            break;
-          }
-        index_on_combo++;
-      }
-  }
-
-  /* 3d */
-  if (self->priv->unity_settings)
-    g_settings_set_int (self->priv->unity_settings, UNITY_LAUNCHER_ALL_MONITORS_KEY, value);
-  /* 2d */
-  if (self->priv->unity2d_settings_launcher)
-    g_settings_set_boolean (self->priv->unity2d_settings_launcher, "only-one-launcher", !on_all_monitors);
-}
-
-static void
-on_ui_scale_monitor_combo_setting_changed (GSettings* settings,
-                                           guint key,
-                                           CcDisplayPanel *self)
-{
-  refresh_unity_monitor_scale (self);
-}
-
-static void
-on_ui_scale_monitor_combo_changed (GtkComboBox *combo, CcDisplayPanel *self)
-{
-  gint active = gtk_combo_box_get_active (combo);
-  gint i;
-  gint index_on_combo = 0;
-  gchar *scale_monitor = NULL;
-
-  if (active < 0)
-    return;
-
-  GnomeRROutputInfo **outputs = gnome_rr_config_get_outputs (self->priv->current_configuration);
-
-  for (i = 0; outputs[i] != NULL; ++i)
-    {
-      GnomeRROutputInfo *output = outputs[i];
-      if (!gnome_rr_output_info_is_active (output))
-        continue;
-
-      if (active == index_on_combo)
-        {
-          scale_monitor = g_strdup (gnome_rr_output_info_get_name (output));
-          break;
-        }
-      index_on_combo++;
-    }
-
-    if (!scale_monitor)
-      {
-        scale_monitor = g_strdup("");
-
-        if (active >= index_on_combo)
-          {
-            gboolean use_max_scaled_monitor = (active == index_on_combo);
-            gboolean fallback_setting = g_settings_get_boolean (self->priv->unity_ui_settings, UNITY_UI_SCALE_FALLBACK_TO_MAX);
-
-            if (fallback_setting != use_max_scaled_monitor)
-              g_settings_set_boolean (self->priv->unity_ui_settings, UNITY_UI_SCALE_FALLBACK_TO_MAX, use_max_scaled_monitor);
-          }
-      }
-
-  gchar *current_setting = g_settings_get_string (self->priv->unity_ui_settings, UNITY_UI_SCALE_FACTOR_MONITOR);
-
-  if (g_strcmp0 (current_setting, scale_monitor) != 0)
-    g_settings_set_string (self->priv->unity_ui_settings, UNITY_UI_SCALE_FACTOR_MONITOR, scale_monitor);
-
-  g_free (current_setting);
-  g_free (scale_monitor);
-}
-
-static void
-setup_unity_settings (CcDisplayPanel *self)
-{
-  GSettingsSchema *schema;
-
-  /* Only use the unity-2d schema if it's installed */
-  schema = g_settings_schema_source_lookup (g_settings_schema_source_get_default (), UNITY2D_GSETTINGS_MAIN, TRUE);
-  if (schema)
-    {
-      self->priv->unity2d_settings_main = g_settings_new (UNITY2D_GSETTINGS_MAIN);
-      self->priv->unity2d_settings_launcher = g_settings_new (UNITY2D_GSETTINGS_LAUNCHER);
-      g_settings_schema_unref (schema);
-    }
-  schema = g_settings_schema_source_lookup (g_settings_schema_source_get_default (), UNITY_GSETTINGS_SCHEMA, TRUE);
-  if (schema)
-    {
-      self->priv->unity_settings = g_settings_new_with_path (UNITY_GSETTINGS_SCHEMA, UNITY_GSETTINGS_PATH);
-      g_settings_schema_unref (schema);
-    }
-
-  schema = g_settings_schema_source_lookup (g_settings_schema_source_get_default (), UNITY_UI_GSETTINGS_SCHEMA, TRUE);
-  if (schema)
-    {
-      self->priv->unity_ui_settings = g_settings_new (UNITY_UI_GSETTINGS_SCHEMA);
-      g_settings_schema_unref (schema);
-    }
-
-  if (!self->priv->unity_settings || !self->priv->unity_ui_settings)
-    return;
-
-  GtkWidget *sticky_edge_switch = WID ("stickyedge_switch");
-  g_signal_connect (sticky_edge_switch, "notify::active",
-                    G_CALLBACK (on_stickyedge_changed), self);
-  g_signal_connect (self->priv->unity_settings, "changed::" UNITY_STICKY_EDGE_KEY,
-                    G_CALLBACK (ext_stickyedge_changed_callback), sticky_edge_switch);
-  stickyedge_widget_refresh (GTK_SWITCH (sticky_edge_switch), self->priv->unity_settings);
-
-  g_signal_connect (G_OBJECT (WID ("launcher_placement_combo")), "changed",
-                    G_CALLBACK (on_launcher_placement_combo_changed), self);
-  g_signal_connect (self->priv->unity_settings, "changed::" UNITY_LAUNCHER_ALL_MONITORS_KEY,
-                    G_CALLBACK (ext_launcher_placement_changed_callback), self);
-
-  g_signal_connect (G_OBJECT (WID ("ui_scale_monitor_combo")), "changed",
-                    G_CALLBACK (on_ui_scale_monitor_combo_changed), self);
-  g_signal_connect (self->priv->unity_ui_settings, "changed::" UNITY_UI_SCALE_FACTOR_MONITOR,
-                    G_CALLBACK (on_ui_scale_monitor_combo_setting_changed), self);
-  g_signal_connect (self->priv->unity_ui_settings, "changed::" UNITY_UI_SCALE_FALLBACK_TO_MAX,
-                    G_CALLBACK (on_ui_scale_monitor_combo_setting_changed), self);
-}
-
-static void
-cc_display_panel_init (CcDisplayPanel *self)
-{
-}
-
-static GObject *
-cc_display_panel_constructor (GType                  gtype,
-                              guint                  n_properties,
-                              GObjectConstructParam *properties)
-{
-  GtkBuilder *builder;
-  GtkWidget *align;
-  GError *error;
-  GObject *obj;
-  CcDisplayPanel *self;
-  CcShell *shell;
-  GtkWidget *toplevel;
-  gchar *objects[] = {"display-panel", "available_launcher_placement_store",
-                      "available_ui_scale_monitor_store", NULL};
-
-  obj = G_OBJECT_CLASS (cc_display_panel_parent_class)->constructor (gtype, n_properties, properties);
-  self = CC_DISPLAY_PANEL (obj);
-  self->priv = DISPLAY_PANEL_PRIVATE (self);
-
-  error = NULL;
-  self->priv->builder = builder = gtk_builder_new ();
-
-  if (!gtk_builder_add_objects_from_file (builder, UIDIR "/display-capplet.ui", objects, &error))
-    {
-      g_warning ("Could not parse UI definition: %s", error->message);
-      g_error_free (error);
-      g_object_unref (builder);
-      return obj;
-    }
-
-  self->priv->screen = gnome_rr_screen_new (gdk_screen_get_default (), &error);
-  g_signal_connect (self->priv->screen, "changed", G_CALLBACK (on_screen_changed), self);
-  if (!self->priv->screen)
-    {
-      error_message (NULL, _("Could not get screen information"), error->message);
-      g_error_free (error);
-      g_object_unref (builder);
-      return obj;
-    }
-
-  self->priv->clock_settings = g_settings_new (CLOCK_SCHEMA);
-  self->priv->desktop_settings = g_settings_new (DESKTOP_GSETTINGS_SCHEMA);
-
-  shell = cc_panel_get_shell (CC_PANEL (self));
-  toplevel = cc_shell_get_toplevel (shell);
-  self->priv->focus_id = g_signal_connect (toplevel, "notify::has-toplevel-focus",
-                                           G_CALLBACK (dialog_toplevel_focus_changed), self);
-
-  self->priv->panel = WID ("display-panel");
-  g_signal_connect_after (self->priv->panel, "show",
-                          G_CALLBACK (dialog_map_event_cb), self);
-
-  self->priv->current_monitor_event_box = WID ("current_monitor_event_box");
-  self->priv->current_monitor_label = WID ("current_monitor_label");
-
-  self->priv->monitor_switch = WID ("monitor_switch");
-  g_signal_connect (self->priv->monitor_switch, "notify::active",
-                    G_CALLBACK (monitor_switch_active_cb), self);
-
-  self->priv->resolution_combo = WID ("resolution_combo");
-  g_signal_connect (self->priv->resolution_combo, "changed",
-                    G_CALLBACK (on_resolution_changed), self);
-
-  self->priv->rotation_combo = WID ("rotation_combo");
-  g_signal_connect (self->priv->rotation_combo, "changed",
-                    G_CALLBACK (on_rotation_changed), self);
-
-  self->priv->ui_scale = WID ("ui_scale");
-  g_signal_connect (self->priv->ui_scale, "button-press-event",
-                    G_CALLBACK (on_ui_scale_button_press), self);
-  g_signal_connect (self->priv->ui_scale, "button-release-event",
-                    G_CALLBACK (on_ui_scale_button_release), self);
-  g_signal_connect (self->priv->ui_scale, "format-value",
-                    G_CALLBACK (on_ui_scale_format_value), self);
-
-  self->priv->clone_checkbox = WID ("clone_checkbox");
-  g_signal_connect (self->priv->clone_checkbox, "toggled",
-                    G_CALLBACK (on_clone_changed), self);
-
-  self->priv->clone_label    = WID ("clone_resolution_warning_label");
-
-  g_signal_connect (WID ("detect_displays_button"),
-                    "clicked", G_CALLBACK (on_detect_displays), self);
-
-  make_text_combo (self->priv->resolution_combo, 4);
-  make_text_combo (self->priv->rotation_combo, -1);
-
-  /* Scroll Area */
-  self->priv->area = (GtkWidget *)foo_scroll_area_new ();
-
-  g_object_set_data (G_OBJECT (self->priv->area), "panel", self);
-
-  set_monitors_tooltip (self, FALSE);
-
-  /* FIXME: this should be computed dynamically */
-  foo_scroll_area_set_min_size (FOO_SCROLL_AREA (self->priv->area), 0, 200);
-  gtk_widget_show (self->priv->area);
-  g_signal_connect (self->priv->area, "paint",
-                    G_CALLBACK (on_area_paint), self);
-  g_signal_connect (self->priv->area, "viewport_changed",
-                    G_CALLBACK (on_viewport_changed), self);
-
-  align = WID ("align");
-
-  gtk_container_add (GTK_CONTAINER (align), self->priv->area);
-
-  g_signal_connect_swapped (WID ("apply_button"),
-                            "clicked", G_CALLBACK (apply), self);
-
-  /* Unity settings */
-  if (is_unity_session ())
-    setup_unity_settings (self);
-  else
-    {
-      gtk_widget_hide (WID ("unity_launcher_placement_sep"));
-      gtk_widget_hide (WID ("launcher_placement_label"));
-      gtk_widget_hide (WID ("sticky_edge_label"));
-      gtk_widget_hide (WID ("launcher_placement_combo"));
-      gtk_widget_hide (WID ("stickyedge_switch"));
-      gtk_widget_hide (WID ("ui_scale_separator"));
-      gtk_widget_hide (WID ("ui_scale_label"));
-      gtk_widget_hide (WID ("ui_scale"));
-      gtk_widget_hide (WID ("ui_scale_monitor_label"));
-      gtk_widget_hide (WID ("ui_scale_monitor_combo"));
-    }
-
-  gtk_widget_show (self->priv->panel);
-  gtk_container_add (GTK_CONTAINER (self), self->priv->panel);
-
-  on_screen_changed (self->priv->screen, self);
-
-  return obj;
-}
-
-void
-cc_display_panel_register (GIOModule *module)
-{
-  cc_display_panel_register_type (G_TYPE_MODULE (module));
-  g_io_extension_point_implement (CC_SHELL_PANEL_EXTENSION_POINT,
-                                  CC_TYPE_DISPLAY_PANEL,
-                                  "display", 0);
-}
diff --git a/panels/display/cc-display-panel.h b/panels/display/cc-display-panel.h
deleted file mode 100644
index 75ef4a4..0000000
--- a/panels/display/cc-display-panel.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2010 Intel, Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Author: Thomas Wood <thomas.wood@intel.com>
- *
- */
-
-
-#ifndef _CC_DISPLAY_PANEL_H
-#define _CC_DISPLAY_PANEL_H
-
-#include <shell/cc-panel.h>
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_DISPLAY_PANEL cc_display_panel_get_type()
-
-#define CC_DISPLAY_PANEL(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
-  CC_TYPE_DISPLAY_PANEL, CcDisplayPanel))
-
-#define CC_DISPLAY_PANEL_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST ((klass), \
-  CC_TYPE_DISPLAY_PANEL, CcDisplayPanelClass))
-
-#define CC_IS_DISPLAY_PANEL(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
-  CC_TYPE_DISPLAY_PANEL))
-
-#define CC_IS_DISPLAY_PANEL_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
-  CC_TYPE_DISPLAY_PANEL))
-
-#define CC_DISPLAY_PANEL_GET_CLASS(obj) \
-  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
-  CC_TYPE_DISPLAY_PANEL, CcDisplayPanelClass))
-
-typedef struct _CcDisplayPanel CcDisplayPanel;
-typedef struct _CcDisplayPanelClass CcDisplayPanelClass;
-typedef struct _CcDisplayPanelPrivate CcDisplayPanelPrivate;
-
-struct _CcDisplayPanel
-{
-  CcPanel parent;
-
-  CcDisplayPanelPrivate *priv;
-};
-
-struct _CcDisplayPanelClass
-{
-  CcPanelClass parent_class;
-};
-
-GType cc_display_panel_get_type (void) G_GNUC_CONST;
-
-void  cc_display_panel_register (GIOModule *module);
-
-G_END_DECLS
-
-#endif /* _CC_DISPLAY_PANEL_H */
diff --git a/panels/display/cc-rr-labeler.c b/panels/display/cc-rr-labeler.c
deleted file mode 100644
index 28926ee..0000000
--- a/panels/display/cc-rr-labeler.c
+++ /dev/null
@@ -1,601 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
- *
- * cc-rr-labeler.c - Utility to label monitors to identify them
- * while they are being configured.
- *
- * Copyright 2008, Novell, Inc.
- *
- * This file is part of the Gnome Library.
- *
- * The Gnome Library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * The Gnome Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with the Gnome Library; see the file COPYING.LIB.  If not,
- * write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- *
- * Author: Federico Mena-Quintero <federico@novell.com>
- */
-
-#include <config.h>
-#include <glib/gi18n-lib.h>
-#include <gtk/gtk.h>
-
-#include <X11/Xproto.h>
-#include <X11/Xlib.h>
-#include <X11/Xutil.h>
-#include <X11/Xatom.h>
-#include <gdk/gdkx.h>
-
-#include "cc-rr-labeler.h"
-
-struct _CcRRLabelerPrivate {
-	GnomeRRConfig *config;
-
-	int num_outputs;
-
-	GdkRGBA *palette;
-	GtkWidget **windows;
-
-	GdkScreen  *screen;
-	Atom        workarea_atom;
-};
-
-enum {
-	PROP_0,
-	PROP_CONFIG,
-	PROP_LAST
-};
-
-G_DEFINE_TYPE (CcRRLabeler, cc_rr_labeler, G_TYPE_OBJECT);
-
-static void cc_rr_labeler_finalize (GObject *object);
-static void setup_from_config (CcRRLabeler *labeler);
-
-static GdkFilterReturn
-screen_xevent_filter (GdkXEvent      *xevent,
-		      GdkEvent       *event,
-		      CcRRLabeler *labeler)
-{
-	XEvent *xev;
-
-	xev = (XEvent *) xevent;
-
-	if (xev->type == PropertyNotify &&
-	    xev->xproperty.atom == labeler->priv->workarea_atom) {
-		/* update label positions */
-		if (labeler->priv->windows != NULL) {
-			cc_rr_labeler_hide (labeler);
-			cc_rr_labeler_show (labeler);
-		}
-	}
-
-	return GDK_FILTER_CONTINUE;
-}
-
-static void
-cc_rr_labeler_init (CcRRLabeler *labeler)
-{
-	GdkWindow *gdkwindow;
-
-	labeler->priv = G_TYPE_INSTANCE_GET_PRIVATE (labeler, GNOME_TYPE_RR_LABELER, CcRRLabelerPrivate);
-
-	labeler->priv->workarea_atom = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-						    "_NET_WORKAREA",
-						    True);
-
-	labeler->priv->screen = gdk_screen_get_default ();
-	/* code is not really designed to handle multiple screens so *shrug* */
-	gdkwindow = gdk_screen_get_root_window (labeler->priv->screen);
-	gdk_window_add_filter (gdkwindow, (GdkFilterFunc) screen_xevent_filter, labeler);
-	gdk_window_set_events (gdkwindow, gdk_window_get_events (gdkwindow) | GDK_PROPERTY_CHANGE_MASK);
-}
-
-static void
-cc_rr_labeler_set_property (GObject *gobject, guint property_id, const GValue *value, GParamSpec *param_spec)
-{
-	CcRRLabeler *self = CC_RR_LABELER (gobject);
-
-	switch (property_id) {
-	case PROP_CONFIG:
-		self->priv->config = GNOME_RR_CONFIG (g_value_dup_object (value));
-		return;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, property_id, param_spec);
-	}
-}
-
-static GObject *
-cc_rr_labeler_constructor (GType type, guint n_construct_properties, GObjectConstructParam *construct_properties)
-{
-	CcRRLabeler *self = (CcRRLabeler*) G_OBJECT_CLASS (cc_rr_labeler_parent_class)->constructor (type, n_construct_properties, construct_properties);
-
-	setup_from_config (self);
-
-	return (GObject*) self;
-}
-
-static void
-cc_rr_labeler_class_init (CcRRLabelerClass *klass)
-{
-	GObjectClass *object_class;
-
-	g_type_class_add_private (klass, sizeof (CcRRLabelerPrivate));
-
-	object_class = (GObjectClass *) klass;
-
-	object_class->set_property = cc_rr_labeler_set_property;
-	object_class->finalize = cc_rr_labeler_finalize;
-	object_class->constructor = cc_rr_labeler_constructor;
-
-	g_object_class_install_property (object_class, PROP_CONFIG, g_param_spec_object ("config",
-											 "Configuration",
-											 "RandR configuration to label",
-											 GNOME_TYPE_RR_CONFIG,
-											 G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY |
-											 G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB));
-}
-
-static void
-cc_rr_labeler_finalize (GObject *object)
-{
-	CcRRLabeler *labeler;
-	GdkWindow      *gdkwindow;
-
-	labeler = CC_RR_LABELER (object);
-
-	gdkwindow = gdk_screen_get_root_window (labeler->priv->screen);
-	gdk_window_remove_filter (gdkwindow, (GdkFilterFunc) screen_xevent_filter, labeler);
-
-	if (labeler->priv->config != NULL) {
-		g_object_unref (labeler->priv->config);
-	}
-
-	if (labeler->priv->windows != NULL) {
-		cc_rr_labeler_hide (labeler);
-		g_free (labeler->priv->windows);
-	}
-
-	g_free (labeler->priv->palette);
-
-	G_OBJECT_CLASS (cc_rr_labeler_parent_class)->finalize (object);
-}
-
-static int
-count_outputs (GnomeRRConfig *config)
-{
-	int i;
-	GnomeRROutputInfo **outputs = gnome_rr_config_get_outputs (config);
-
-	for (i = 0; outputs[i] != NULL; i++)
-		;
-
-	return i;
-}
-
-static void
-make_palette (CcRRLabeler *labeler)
-{
-	/* The idea is that we go around an hue color wheel.  We want to start
-	 * at red, go around to green/etc. and stop at blue --- because magenta
-	 * is evil.  Eeeeek, no magenta, please!
-	 *
-	 * Purple would be nice, though.  Remember that we are watered down
-	 * (i.e. low saturation), so that would be like Like berries with cream.
-	 * Mmmmm, berries.
-	 */
-	double start_hue;
-	double end_hue;
-	int i;
-
-	g_assert (labeler->priv->num_outputs > 0);
-
-	labeler->priv->palette = g_new (GdkRGBA, labeler->priv->num_outputs);
-
-	start_hue = 0.0; /* red */
-	end_hue   = 2.0/3; /* blue */
-
-	for (i = 0; i < labeler->priv->num_outputs; i++) {
-		double h, s, v;
-		double r, g, b;
-
-		h = start_hue + (end_hue - start_hue) / labeler->priv->num_outputs * i;
-		s = 1.0 / 3;
-		v = 1.0;
-
-		gtk_hsv_to_rgb (h, s, v, &r, &g, &b);
-
-		labeler->priv->palette[i].red   = r;
-		labeler->priv->palette[i].green = g;
-		labeler->priv->palette[i].blue  = b;
-		labeler->priv->palette[i].alpha  = 1.0;
-	}
-}
-
-static void
-rounded_rectangle (cairo_t *cr,
-                   gint     x,
-                   gint     y,
-                   gint     width,
-                   gint     height,
-                   gint     x_radius,
-                   gint     y_radius)
-{
-	gint x1, x2;
-	gint y1, y2;
-	gint xr1, xr2;
-	gint yr1, yr2;
-
-	x1 = x;
-	x2 = x1 + width;
-	y1 = y;
-	y2 = y1 + height;
-
-	x_radius = MIN (x_radius, width / 2.0);
-	y_radius = MIN (y_radius, width / 2.0);
-
-	xr1 = x_radius;
-	xr2 = x_radius / 2.0;
-	yr1 = y_radius;
-	yr2 = y_radius / 2.0;
-
-	cairo_move_to    (cr, x1 + xr1, y1);
-	cairo_line_to    (cr, x2 - xr1, y1);
-	cairo_curve_to   (cr, x2 - xr2, y1, x2, y1 + yr2, x2, y1 + yr1);
-	cairo_line_to    (cr, x2, y2 - yr1);
-	cairo_curve_to   (cr, x2, y2 - yr2, x2 - xr2, y2, x2 - xr1, y2);
-	cairo_line_to    (cr, x1 + xr1, y2);
-	cairo_curve_to   (cr, x1 + xr2, y2, x1, y2 - yr2, x1, y2 - yr1);
-	cairo_line_to    (cr, x1, y1 + yr1);
-	cairo_curve_to   (cr, x1, y1 + yr2, x1 + xr2, y1, x1 + xr1, y1);
-	cairo_close_path (cr);
-}
-
-#define LABEL_WINDOW_EDGE_THICKNESS 2
-#define LABEL_WINDOW_PADDING 12
-/* Look for panel-corner in:
- * http://git.gnome.org/browse/gnome-shell/tree/data/theme/gnome-shell.css
- * to match the corner radius */
-#define LABEL_CORNER_RADIUS 6 + LABEL_WINDOW_EDGE_THICKNESS
-
-static void
-label_draw_background_and_frame (GtkWidget *widget, cairo_t *cr, gboolean for_shape)
-{
-	GdkRGBA shape_color = { 0, 0, 0, 1 };
-	GdkRGBA *rgba;
-	GtkAllocation allocation;
-
-	rgba = g_object_get_data (G_OBJECT (widget), "rgba");
-	gtk_widget_get_allocation (widget, &allocation);
-
-	cairo_save (cr);
-	cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
-
-	/* edge outline */
-	if (for_shape)
-		gdk_cairo_set_source_rgba (cr, &shape_color);
-	else
-		cairo_set_source_rgba (cr, 0, 0, 0, 0.5);
-
-	rounded_rectangle (cr,
-	                   LABEL_WINDOW_EDGE_THICKNESS / 2.0,
-	                   LABEL_WINDOW_EDGE_THICKNESS / 2.0,
-	                   allocation.width - LABEL_WINDOW_EDGE_THICKNESS,
-	                   allocation.height - LABEL_WINDOW_EDGE_THICKNESS,
-	                   LABEL_CORNER_RADIUS, LABEL_CORNER_RADIUS);
-	cairo_set_line_width (cr, LABEL_WINDOW_EDGE_THICKNESS);
-	cairo_stroke (cr);
-
-	/* fill */
-	if (for_shape) {
-		gdk_cairo_set_source_rgba (cr, &shape_color);
-	} else {
-		rgba->alpha = 0.75;
-		gdk_cairo_set_source_rgba (cr, rgba);
-	}
-
-	rounded_rectangle (cr,
-	                   LABEL_WINDOW_EDGE_THICKNESS,
-	                   LABEL_WINDOW_EDGE_THICKNESS,
-	                   allocation.width - LABEL_WINDOW_EDGE_THICKNESS * 2,
-	                   allocation.height - LABEL_WINDOW_EDGE_THICKNESS * 2,
-	                   LABEL_CORNER_RADIUS - LABEL_WINDOW_EDGE_THICKNESS / 2.0,
-			   LABEL_CORNER_RADIUS - LABEL_WINDOW_EDGE_THICKNESS / 2.0);
-	cairo_fill (cr);
-
-	cairo_restore (cr);
-}
-
-static void
-maybe_update_shape (GtkWidget *widget)
-{
-	cairo_t *cr;
-	cairo_surface_t *surface;
-	cairo_region_t *region;
-
-	/* fallback to XShape only for non-composited clients */
-	if (gtk_widget_is_composited (widget)) {
-		gtk_widget_shape_combine_region (widget, NULL);
-		return;
-	}
-
-	surface = gdk_window_create_similar_surface (gtk_widget_get_window (widget),
-						     CAIRO_CONTENT_COLOR_ALPHA,
-						     gtk_widget_get_allocated_width (widget),
-						     gtk_widget_get_allocated_height (widget));
-
-	cr = cairo_create (surface);
-	label_draw_background_and_frame (widget, cr, TRUE);
-	cairo_destroy (cr);
-
-	region = gdk_cairo_region_create_from_surface (surface);
-	gtk_widget_shape_combine_region (widget, region);
-
-	cairo_surface_destroy (surface);
-	cairo_region_destroy (region);
-}
-
-static gboolean
-label_window_draw_event_cb (GtkWidget *widget, cairo_t *cr, gpointer data)
-{
-	if (gtk_widget_is_composited (widget)) {
-		/* clear any content */
-		cairo_save (cr);
-		cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
-		cairo_set_source_rgba (cr, 0, 0, 0, 0);
-		cairo_paint (cr);
-		cairo_restore (cr);
-	}
-
-	maybe_update_shape (widget);
-	label_draw_background_and_frame (widget, cr, FALSE);
-
-	return FALSE;
-}
-
-static void
-position_window (CcRRLabeler  *labeler,
-		 GtkWidget       *window,
-		 int              x,
-		 int              y)
-{
-	GdkRectangle    workarea;
-	GdkRectangle    monitor;
-	int             monitor_num;
-
-	monitor_num = gdk_screen_get_monitor_at_point (labeler->priv->screen, x, y);
-	gdk_screen_get_monitor_workarea (labeler->priv->screen, monitor_num, &workarea);
-	gdk_screen_get_monitor_geometry (labeler->priv->screen,
-                                         monitor_num,
-                                         &monitor);
-	gdk_rectangle_intersect (&monitor, &workarea, &workarea);
-
-	gtk_window_move (GTK_WINDOW (window), workarea.x, workarea.y);
-}
-
-static void
-label_window_realize_cb (GtkWidget *widget)
-{
-	cairo_region_t *region;
-
-	/* make the whole window ignore events */
-	region = cairo_region_create ();
-	gtk_widget_input_shape_combine_region (widget, region);
-	cairo_region_destroy (region);
-
-	maybe_update_shape (widget);
-}
-
-static void
-label_window_composited_changed_cb (GtkWidget *widget, CcRRLabeler *labeler)
-{
-	if (gtk_widget_get_realized (widget))
-		maybe_update_shape (widget);
-}
-
-static GtkWidget *
-create_label_window (CcRRLabeler *labeler, GnomeRROutputInfo *output, GdkRGBA *rgba)
-{
-	GtkWidget *window;
-	GtkWidget *widget;
-	char *str;
-	const char *display_name;
-	GdkRGBA black = { 0, 0, 0, 1.0 };
-	int x, y;
-	GdkScreen *screen;
-	GdkVisual *visual;
-
-	window = gtk_window_new (GTK_WINDOW_POPUP);
-	gtk_window_set_type_hint (GTK_WINDOW (window), GDK_WINDOW_TYPE_HINT_TOOLTIP);
-	gtk_window_set_resizable (GTK_WINDOW (window), FALSE);
-	gtk_widget_set_app_paintable (window, TRUE);
-	screen = gtk_widget_get_screen (window);
-	visual = gdk_screen_get_rgba_visual (screen);
-
-	if (visual != NULL)
-		gtk_widget_set_visual (window, visual);
-
-	gtk_container_set_border_width (GTK_CONTAINER (window), LABEL_WINDOW_PADDING + LABEL_WINDOW_EDGE_THICKNESS);
-
-	/* This is semi-dangerous.  The color is part of the labeler->palette
-	 * array.  Note that in cc_rr_labeler_finalize(), we are careful to
-	 * free the palette only after we free the windows.
-	 */
-	g_object_set_data (G_OBJECT (window), "rgba", rgba);
-
-	g_signal_connect (window, "draw",
-			  G_CALLBACK (label_window_draw_event_cb), labeler);
-	g_signal_connect (window, "realize",
-			  G_CALLBACK (label_window_realize_cb), labeler);
-	g_signal_connect (window, "composited-changed",
-			  G_CALLBACK (label_window_composited_changed_cb), labeler);
-
-	if (gnome_rr_config_get_clone (labeler->priv->config)) {
-		/* Keep this string in sync with gnome-control-center/capplets/display/xrandr-capplet.c:get_display_name() */
-
-		/* Translators:  this is the feature where what you see on your
-		 * laptop's screen is the same as your external projector.
-		 * Here, "Mirrored" is being used as an adjective.  For example,
-		 * the Spanish translation could be "Pantallas en Espejo".
-		 */
-		display_name = _("Mirrored Displays");
-	} else
-		display_name = gnome_rr_output_info_get_display_name (output);
-
-	str = g_strdup_printf ("<b>%s</b>", display_name);
-	widget = gtk_label_new (NULL);
-	gtk_label_set_markup (GTK_LABEL (widget), str);
-	g_free (str);
-
-	/* Make the label explicitly black.  We don't want it to follow the
-	 * theme's colors, since the label is always shown against a light
-	 * pastel background.  See bgo#556050
-	 */
-	gtk_widget_override_color (widget,
-				   gtk_widget_get_state_flags (widget),
-				   &black);
-
-	gtk_container_add (GTK_CONTAINER (window), widget);
-
-	/* Should we center this at the top edge of the monitor, instead of using the upper-left corner? */
-	gnome_rr_output_info_get_geometry (output, &x, &y, NULL, NULL);
-	position_window (labeler, window, x, y);
-
-	gtk_widget_show_all (window);
-
-	return window;
-}
-
-static void
-setup_from_config (CcRRLabeler *labeler)
-{
-	labeler->priv->num_outputs = count_outputs (labeler->priv->config);
-
-	make_palette (labeler);
-
-	cc_rr_labeler_show (labeler);
-}
-
-/**
- * cc_rr_labeler_new:
- * @config: Configuration of the screens to label
- *
- * Create a GUI element that will display colored labels on each connected monitor.
- * This is useful when users are required to identify which monitor is which, e.g. for
- * for configuring multiple monitors.
- * The labels will be shown by default, use cc_rr_labeler_hide to hide them.
- *
- * Returns: A new #CcRRLabeler
- */
-CcRRLabeler *
-cc_rr_labeler_new (GnomeRRConfig *config)
-{
-	g_return_val_if_fail (GNOME_IS_RR_CONFIG (config), NULL);
-
-	return g_object_new (GNOME_TYPE_RR_LABELER, "config", config, NULL);
-}
-
-/**
- * cc_rr_labeler_show:
- * @labeler: A #CcRRLabeler
- *
- * Show the labels.
- */
-void
-cc_rr_labeler_show (CcRRLabeler *labeler)
-{
-	int i;
-	gboolean created_window_for_clone;
-	GnomeRROutputInfo **outputs;
-
-	g_return_if_fail (GNOME_IS_RR_LABELER (labeler));
-
-	if (labeler->priv->windows != NULL)
-		return;
-
-	labeler->priv->windows = g_new (GtkWidget *, labeler->priv->num_outputs);
-
-	created_window_for_clone = FALSE;
-
-	outputs = gnome_rr_config_get_outputs (labeler->priv->config);
-
-	for (i = 0; i < labeler->priv->num_outputs; i++) {
-		if (!created_window_for_clone && gnome_rr_output_info_is_active (outputs[i])) {
-			labeler->priv->windows[i] = create_label_window (labeler, outputs[i], labeler->priv->palette + i);
-
-			if (gnome_rr_config_get_clone (labeler->priv->config))
-				created_window_for_clone = TRUE;
-		} else
-			labeler->priv->windows[i] = NULL;
-	}
-}
-
-/**
- * cc_rr_labeler_hide:
- * @labeler: A #CcRRLabeler
- *
- * Hide ouput labels.
- */
-void
-cc_rr_labeler_hide (CcRRLabeler *labeler)
-{
-	int i;
-	CcRRLabelerPrivate *priv;
-
-	g_return_if_fail (GNOME_IS_RR_LABELER (labeler));
-
-	priv = labeler->priv;
-
-	if (priv->windows == NULL)
-		return;
-
-	for (i = 0; i < priv->num_outputs; i++)
-		if (priv->windows[i] != NULL) {
-			gtk_widget_destroy (priv->windows[i]);
-			priv->windows[i] = NULL;
-	}
-	g_free (priv->windows);
-	priv->windows = NULL;
-}
-
-/**
- * cc_rr_labeler_get_rgba_for_output:
- * @labeler: A #CcRRLabeler
- * @output: Output device (i.e. monitor) to query
- * @rgba_out: (out): Color of selected monitor.
- *
- * Get the color used for the label on a given output (monitor).
- */
-void
-cc_rr_labeler_get_rgba_for_output (CcRRLabeler *labeler, GnomeRROutputInfo *output, GdkRGBA *rgba_out)
-{
-	int i;
-	GnomeRROutputInfo **outputs;
-
-	g_return_if_fail (GNOME_IS_RR_LABELER (labeler));
-	g_return_if_fail (GNOME_IS_RR_OUTPUT_INFO (output));
-	g_return_if_fail (rgba_out != NULL);
-
-	outputs = gnome_rr_config_get_outputs (labeler->priv->config);
-
-	for (i = 0; i < labeler->priv->num_outputs; i++)
-		if (outputs[i] == output) {
-			*rgba_out = labeler->priv->palette[i];
-			return;
-		}
-
-	g_warning ("trying to get the color for unknown GnomeOutputInfo %p; returning magenta!", output);
-
-	rgba_out->red   = 1.0;
-	rgba_out->green = 0;
-	rgba_out->blue  = 1.0;
-	rgba_out->alpha  = 1.0;
-}
diff --git a/panels/display/cc-rr-labeler.h b/panels/display/cc-rr-labeler.h
deleted file mode 100644
index fdecf29..0000000
--- a/panels/display/cc-rr-labeler.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/* gnome-rr-labeler.h - Utility to label monitors to identify them
- * while they are being configured.
- *
- * Copyright 2008, Novell, Inc.
- *
- * This file is part of the Gnome Library.
- *
- * The Gnome Library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * The Gnome Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with the Gnome Library; see the file COPYING.LIB.  If not,
- * write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- *
- * Author: Federico Mena-Quintero <federico@novell.com>
- */
-
-#ifndef CC_RR_LABELER_H
-#define CC_RR_LABELER_H
-
-#define GNOME_DESKTOP_USE_UNSTABLE_API
-#include <libgnome-desktop/gnome-rr-config.h>
-
-#define GNOME_TYPE_RR_LABELER            (cc_rr_labeler_get_type ())
-#define CC_RR_LABELER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOME_TYPE_RR_LABELER, CcRRLabeler))
-#define CC_RR_LABELER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  GNOME_TYPE_RR_LABELER, CcRRLabelerClass))
-#define GNOME_IS_RR_LABELER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOME_TYPE_RR_LABELER))
-#define GNOME_IS_RR_LABELER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  GNOME_TYPE_RR_LABELER))
-#define CC_RR_LABELER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  GNOME_TYPE_RR_LABELER, CcRRLabelerClass))
-
-typedef struct _CcRRLabeler CcRRLabeler;
-typedef struct _CcRRLabelerClass CcRRLabelerClass;
-typedef struct _CcRRLabelerPrivate CcRRLabelerPrivate;
-
-struct _CcRRLabeler {
-	GObject parent;
-
-	/*< private >*/
-	CcRRLabelerPrivate *priv;
-};
-
-struct _CcRRLabelerClass {
-	GObjectClass parent_class;
-};
-
-GType cc_rr_labeler_get_type (void);
-
-CcRRLabeler *cc_rr_labeler_new (GnomeRRConfig *config);
-
-void cc_rr_labeler_show (CcRRLabeler *labeler);
-
-void cc_rr_labeler_hide (CcRRLabeler *labeler);
-
-void cc_rr_labeler_get_rgba_for_output (CcRRLabeler *labeler, GnomeRROutputInfo *output, GdkRGBA *rgba_out);
-
-#endif
diff --git a/panels/display/display-capplet.ui b/panels/display/display-capplet.ui
deleted file mode 100644
index 5fd2795..0000000
--- a/panels/display/display-capplet.ui
+++ /dev/null
@@ -1,566 +0,0 @@
-<?xml version="1.0"?>
-<interface>
-  <requires lib="gtk+" version="3.0"/>
-  <object class="GtkListStore" id="available_launcher_placement_store">
-    <columns>
-      <!-- column-name MONITOR_PREVIEW -->
-      <column type="GdkPixbuf"/>
-      <!-- column-name LAUNCHER_PLACEMENT_NAME -->
-      <column type="gchararray"/>
-    </columns>
-  </object>
-  <object class="GtkListStore" id="available_ui_scale_monitor_store">
-    <columns>
-      <!-- column-name MONITOR_PREVIEW -->
-      <column type="GdkPixbuf"/>
-      <!-- column-name LAUNCHER_PLACEMENT_NAME -->
-      <column type="gchararray"/>
-    </columns>
-  </object>
-  <!-- interface-naming-policy toplevel-contextual -->
-  <object class="GtkWindow" id="window1">
-    <property name="can_focus">False</property>
-    <child>
-      <object class="GtkVBox" id="display-panel">
-        <property name="visible">True</property>
-        <property name="can_focus">False</property>
-        <property name="border_width">10</property>
-        <property name="spacing">12</property>
-        <child>
-          <object class="GtkAlignment" id="align">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <child>
-              <placeholder/>
-            </child>
-          </object>
-          <packing>
-            <property name="expand">True</property>
-            <property name="fill">True</property>
-            <property name="position">0</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkHBox" id="hbox1">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="spacing">12</property>
-            <child>
-              <object class="GtkVBox" id="vbox1">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="spacing">12</property>
-                <property name="halign">center</property>
-                <child>
-                  <object class="GtkHBox" id="mirror_hbox">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="halign">center</property>
-                    <child>
-                      <object class="GtkCheckButton" id="clone_checkbox">
-                        <property name="visible">True</property>
-                        <property name="xalign">0.5</property>
-                        <property name="draw_indicator">True</property>
-                        <child>
-                          <object class="GtkHBox" id="clone_checkbox_label_hbox">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="halign">center</property>
-                            <child>
-                              <object class="GtkLabel" id="clone_checkbox_label">
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="receives_default">False</property>
-                                <property name="use_underline">True</property>
-                                <property name="label" translatable="yes" comments="Note that mirror is a verb in this string">_Mirror displays</property>
-                              </object>
-                            </child>
-                            <child>
-                              <!-- This is a workaround to not re-translate the warning, to be fixed later. -->
-                              <object class="GtkLabel" id="clone_res_warning_parentesis_open">
-                                <property name="margin_left">2</property>
-                                <property name="visible">True</property>
-                                <property name="can_focus">False</property>
-                                <property name="label" translatable="no">(</property>
-                                <attributes>
-                                  <attribute name="style" value="italic"/>
-                                </attributes>
-                              </object>
-                            </child>
-                            <child>
-                              <object class="GtkLabel" id="clone_resolution_warning_label">
-                                <property name="visible">True</property>
-                                <property name="can_focus">False</property>
-                                <property name="xalign">0</property>
-                                <property name="label" translatable="yes">Note: may limit resolution options</property>
-                                <attributes>
-                                  <attribute name="style" value="italic"/>
-                                </attributes>
-                              </object>
-                            </child>
-                            <child>
-                              <!-- This is a workaround to not re-translate the warning, to be fixed later. -->
-                              <object class="GtkLabel" id="clone_res_warning_parentesis_open_close">
-                                <property name="visible">True</property>
-                                <property name="can_focus">False</property>
-                                <property name="label" translatable="no">)</property>
-                                <attributes>
-                                  <attribute name="style" value="italic"/>
-                                </attributes>
-                              </object>
-                            </child>
-                          </object>
-                        </child>
-                      </object>
-                      <packing>
-                        <property name="expand">False</property>
-                        <property name="fill">False</property>
-                      </packing>
-                    </child>
-                  </object>
-                </child>
-                <child>
-                  <object class="GtkAlignment" id="alignment1">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="xalign">0</property>
-                    <property name="yalign">0</property>
-                    <child>
-                      <object class="GtkTable" id="table1">
-                        <property name="visible">True</property>
-                        <property name="can_focus">False</property>
-                        <property name="column_spacing">12</property>
-                        <property name="row_spacing">6</property>
-                        <child>
-                          <object class="GtkHBox" id="hbox3">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="spacing">12</property>
-                            <child>
-                              <object class="GtkEventBox" id="current_monitor_event_box">
-                                <property name="visible">True</property>
-                                <property name="can_focus">False</property>
-                                <child>
-                                  <object class="GtkLabel" id="current_monitor_label">
-                                    <property name="visible">True</property>
-                                    <property name="can_focus">False</property>
-                                    <property name="xalign">0</property>
-                                    <property name="ypad">5</property>
-                                    <property name="label" translatable="yes">Monitor</property>
-                                    <attributes>
-                                      <attribute name="weight" value="bold"/>
-                                    </attributes>
-                                  </object>
-                                </child>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="position">0</property>
-                              </packing>
-                            </child>
-                            <child>
-                              <object class="GtkHBox" id="hbox2">
-                                <property name="visible">True</property>
-                                <property name="can_focus">False</property>
-                                <property name="spacing">12</property>
-                                <property name="valign">center</property>
-                                <child>
-                                  <object class="GtkSwitch" id="monitor_switch">
-                                    <property name="visible">True</property>
-                                    <property name="can_focus">True</property>
-                                    <property name="active">True</property>
-                                  </object>
-                                  <packing>
-                                    <property name="expand">False</property>
-                                    <property name="fill">False</property>
-                                    <property name="position">0</property>
-                                  </packing>
-                                </child>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="pack_type">start</property>
-                                <property name="position">1</property>
-                              </packing>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="right_attach">2</property>
-                            <property name="x_options">GTK_FILL</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="label2">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">1</property>
-                            <property name="label" translatable="yes">_Resolution</property>
-                            <property name="use_underline">True</property>
-                            <property name="mnemonic_widget">resolution_combo</property>
-                            <style>
-                              <class name="dim-label-ucc"/>
-                            </style>
-                          </object>
-                          <packing>
-                            <property name="top_attach">1</property>
-                            <property name="bottom_attach">2</property>
-                            <property name="x_options">GTK_FILL</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="label5">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">1</property>
-                            <property name="label" translatable="yes">R_otation</property>
-                            <property name="use_underline">True</property>
-                            <property name="mnemonic_widget">rotation_combo</property>
-                            <style>
-                              <class name="dim-label-ucc"/>
-                            </style>
-                          </object>
-                          <packing>
-                            <property name="top_attach">2</property>
-                            <property name="bottom_attach">3</property>
-                            <property name="x_options">GTK_FILL</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="general_options_label">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">0</property>
-                            <property name="ypad">5</property>
-                            <property name="label" translatable="yes">General options</property>
-                            <attributes>
-                              <attribute name="weight" value="bold"/>
-                            </attributes>
-                          </object>
-                          <packing>
-                            <property name="left_attach">3</property>
-                            <property name="right_attach">4</property>
-                            <property name="x_options">GTK_FILL</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="launcher_placement_label">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">1</property>
-                            <property name="label" translatable="yes">L_auncher placement</property>
-                            <property name="use_underline">True</property>
-                            <property name="mnemonic_widget">launcher_placement_combo</property>
-                            <style>
-                              <class name="dim-label-ucc"/>
-                            </style>
-                          </object>
-                          <packing>
-                            <property name="top_attach">1</property>
-                            <property name="bottom_attach">2</property>
-                            <property name="left_attach">3</property>
-                            <property name="right_attach">4</property>
-                            <property name="x_options">GTK_FILL</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="sticky_edge_label">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">1</property>
-                            <property name="label" translatable="yes">S_ticky edges</property>
-                            <property name="use_underline">True</property>
-                            <property name="mnemonic_widget">stickyedge_switch</property>
-                            <style>
-                              <class name="dim-label-ucc"/>
-                            </style>
-                          </object>
-                          <packing>
-                            <property name="left_attach">3</property>
-                            <property name="right_attach">4</property>
-                            <property name="top_attach">2</property>
-                            <property name="bottom_attach">3</property>
-                            <property name="x_options">GTK_FILL</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkComboBox" id="resolution_combo">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                          </object>
-                          <packing>
-                            <property name="left_attach">1</property>
-                            <property name="right_attach">2</property>
-                            <property name="top_attach">1</property>
-                            <property name="bottom_attach">2</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkComboBox" id="rotation_combo">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <child>
-                              <object class="GtkCellRendererText" id="cellrenderertext1"/>
-                              <attributes>
-                                <attribute name="text">0</attribute>
-                              </attributes>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="left_attach">1</property>
-                            <property name="right_attach">2</property>
-                            <property name="top_attach">2</property>
-                            <property name="bottom_attach">3</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkHBox" id="launcher_placement_hbox">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="margin_bottom">1</property>
-                            <property name="spacing">12</property>
-                            <child>
-                              <object class="GtkComboBox" id="launcher_placement_combo">
-                                <property name="visible">True</property>
-                                <property name="can_focus">False</property>
-                                <property name="model">available_launcher_placement_store</property>
-                                <property name="id_column">1</property>
-                                <child>
-                                  <object class="GtkCellRendererPixbuf" id="monitor_preview_renderer"/>
-                                  <attributes>
-                                    <attribute name="pixbuf">0</attribute>
-                                  </attributes>
-                                </child>
-                                <child>
-                                  <object class="GtkCellRendererText" id="launcher_placement_name_renderer"/>
-                                  <attributes>
-                                    <attribute name="text">1</attribute>
-                                  </attributes>
-                                </child>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="pack_type">start</property>
-                                <property name="position">1</property>
-                              </packing>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="left_attach">4</property>
-                            <property name="right_attach">5</property>
-                            <property name="top_attach">1</property>
-                            <property name="bottom_attach">2</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkHBox" id="stickyedge_hbox">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="margin_bottom">1</property>
-                            <property name="spacing">12</property>
-                            <child>
-                              <object class="GtkSwitch" id="stickyedge_switch">
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="active">True</property>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="pack_type">start</property>
-                                <property name="position">1</property>
-                              </packing>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="left_attach">4</property>
-                            <property name="right_attach">5</property>
-                            <property name="top_attach">2</property>
-                            <property name="bottom_attach">3</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="ui_scale_label">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">0</property>
-                            <property name="yalign">1</property>
-                            <property name="label" translatable="yes">Scale for menu and title bars:</property>
-                          </object>
-                          <packing>
-                            <property name="top_attach">3</property>
-                            <property name="bottom_attach">4</property>
-                            <property name="right_attach">2</property>
-                            <property name="x_options">GTK_FILL</property>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkAlignment" id="ui_scale_alignment">
-                            <property name="visible">True</property>
-                            <property name="width_request">150</property>
-                            <property name="xscale">0.75</property>
-                            <property name="xalign">0</property>
-                            <child>
-                              <object class="GtkHScale" id="ui_scale">
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="digits">2</property>
-                                <property name="value_pos">bottom</property>
-                                <child internal-child="accessible">
-                                  <object class="AtkObject" id="ui_scale-atkobject">
-                                    <property name="AtkObject::accessible-description" translatable="yes">User interface scale factor</property>
-                                  </object>
-                                </child>
-                              </object>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="right_attach">2</property>
-                            <property name="top_attach">4</property>
-                            <property name="bottom_attach">5</property>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="ui_scale_monitor_label">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">0</property>
-                            <property name="label" translatable="yes">Scale all window _contents to match:</property>
-                            <property name="use_underline">True</property>
-                            <property name="mnemonic_widget">ui_scale_monitor_combo</property>
-                          </object>
-                          <packing>
-                            <property name="left_attach">3</property>
-                            <property name="right_attach">5</property>
-                            <property name="top_attach">3</property>
-                            <property name="bottom_attach">4</property>
-                            <property name="x_options">GTK_FILL</property>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkHBox" id="ui_scale_monitor_combo_hbox">
-                            <property name="visible">True</property>
-                            <child>
-                              <object class="GtkComboBox" id="ui_scale_monitor_combo">
-                                <property name="visible">True</property>
-                                <property name="can_focus">False</property>
-                                <property name="model">available_ui_scale_monitor_store</property>
-                                <property name="id_column">1</property>
-                                <child>
-                                  <object class="GtkCellRendererPixbuf" id="ui_scale_monitor_preview_renderer"/>
-                                  <attributes>
-                                    <attribute name="pixbuf">0</attribute>
-                                  </attributes>
-                                </child>
-                                <child>
-                                  <object class="GtkCellRendererText" id="ui_scale_name_renderer"/>
-                                  <attributes>
-                                    <attribute name="text">1</attribute>
-                                  </attributes>
-                                </child>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="position">1</property>
-                              </packing>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="left_attach">3</property>
-                            <property name="right_attach">5</property>
-                            <property name="top_attach">4</property>
-                            <property name="bottom_attach">5</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                      </object>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">False</property>
-                    <property name="position">1</property>
-                  </packing>
-                </child>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">False</property>
-                <property name="position">0</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="expand">False</property>
-            <property name="fill">False</property>
-            <property name="position">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkAlignment" id="alignment3">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="top_padding">10</property>
-            <child>
-              <object class="GtkHButtonBox" id="hbuttonbox1">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="spacing">6</property>
-                <property name="layout_style">end</property>
-                <child>
-                  <object class="GtkButton" id="detect_displays_button">
-                    <property name="label" translatable="yes">_Detect Displays</property>
-                    <property name="visible">True</property>
-                    <property name="can_focus">True</property>
-                    <property name="receives_default">True</property>
-                    <property name="use_underline">True</property>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">False</property>
-                    <property name="pack_type">end</property>
-                    <property name="position">0</property>
-                    <property name="secondary">True</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkButton" id="apply_button">
-                    <property name="label">gtk-apply</property>
-                    <property name="visible">True</property>
-                    <property name="can_focus">True</property>
-                    <property name="can_default">True</property>
-                    <property name="receives_default">True</property>
-                    <property name="use_stock">True</property>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">False</property>
-                    <property name="position">1</property>
-                  </packing>
-                </child>
-              </object>
-            </child>
-          </object>
-          <packing>
-            <property name="expand">False</property>
-            <property name="fill">False</property>
-            <property name="position">2</property>
-          </packing>
-        </child>
-      </object>
-    </child>
-  </object>
-</interface>
diff --git a/panels/display/display-module.c b/panels/display/display-module.c
deleted file mode 100644
index 6b250d9..0000000
--- a/panels/display/display-module.c
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2010 Intel, Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Author: Thomas Wood <thomas.wood@intel.com>
- *
- */
-
-#include <config.h>
-
-#include "cc-display-panel.h"
-
-#include <glib/gi18n-lib.h>
-
-void
-g_io_module_load (GIOModule *module)
-{
-  bindtextdomain (GETTEXT_PACKAGE, GNOMELOCALEDIR);
-  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-
-  /* register the panel */
-  cc_display_panel_register (module);
-}
-
-void
-g_io_module_unload (GIOModule *module)
-{
-}
diff --git a/panels/display/foo-marshal.list b/panels/display/foo-marshal.list
deleted file mode 100644
index dea3cd6..0000000
--- a/panels/display/foo-marshal.list
+++ /dev/null
@@ -1,6 +0,0 @@
-VOID:OBJECT,OBJECT
-VOID:UINT,UINT,UINT,UINT
-VOID:UINT,UINT
-VOID:BOXED,BOXED
-VOID:POINTER,BOXED,POINTER
-VOID:POINTER,POINTER
diff --git a/panels/display/icons/24x24/unity-display-panel.svg b/panels/display/icons/24x24/unity-display-panel.svg
deleted file mode 100644
index e8081f2..0000000
--- a/panels/display/icons/24x24/unity-display-panel.svg
+++ /dev/null
@@ -1,55 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-<svg id="svg2666" xmlns="http://www.w3.org/2000/svg" height="24" width="24" version="1.0" xmlns:xlink="http://www.w3.org/1999/xlink">
- <defs id="defs2668">
-  <linearGradient id="linearGradient5778" y2="3" gradientUnits="userSpaceOnUse" x2="25" gradientTransform="matrix(.46342 0 0 .52002 .87781 1.6797)" y1="29" x1="24.875">
-   <stop id="stop6720" style="stop-color:#141414" offset="0"/>
-   <stop id="stop6722" style="stop-color:#3c3c3c" offset="1"/>
-  </linearGradient>
-  <radialGradient id="radialGradient5776" gradientUnits="userSpaceOnUse" cy="4.8631" cx="12.244" gradientTransform="matrix(.64093 .0092819 -.0059676 .51886 -1.2666 3.778)" r="21">
-   <stop id="stop6714" style="stop-color:#3c3c3c" offset="0"/>
-   <stop id="stop6716" style="stop-color:#1e1e1e" offset="1"/>
-  </radialGradient>
-  <linearGradient id="linearGradient5773" y2="19.812" gradientUnits="userSpaceOnUse" x2="15.25" gradientTransform="matrix(.42857 0 0 .53333 1.7143 2.4)" y1="8.4375" x1="12.938">
-   <stop id="stop6594" style="stop-color:#fff;stop-opacity:.27451" offset="0"/>
-   <stop id="stop6596" style="stop-color:#fff;stop-opacity:0" offset="1"/>
-  </linearGradient>
-  <linearGradient id="linearGradient5770" y2="41.181" gradientUnits="userSpaceOnUse" x2="25.208" gradientTransform="matrix(.44889 0 0 .45022 .22662 -2.8314)" y1="28.5" x1="13.63">
-   <stop id="stop7027" style="stop-color:#e6ce46" offset="0"/>
-   <stop id="stop7029" style="stop-color:#d6ba1c" offset="1"/>
-  </linearGradient>
-  <radialGradient id="radialGradient5540" gradientUnits="userSpaceOnUse" cy="5.5643" cx="1" gradientTransform="matrix(.46667 0 0 .33733 .79996 4.6027)" r="23">
-   <stop id="stop6604" style="stop-color:#fff" offset="0"/>
-   <stop id="stop6606" style="stop-color:#fff;stop-opacity:0" offset="1"/>
-  </radialGradient>
-  <linearGradient id="linearGradient5543" y2="31.983" gradientUnits="userSpaceOnUse" x2="20.104" gradientTransform="matrix(.49016 0 0 .54896 .23601 1.2167)" y1="-.00049710" x1="20.147">
-   <stop id="stop6546" style="stop-color:#f0f0f0" offset="0"/>
-   <stop id="stop6548" style="stop-color:#d2d2d2" offset="1"/>
-  </linearGradient>
-  <linearGradient id="linearGradient5547" y2="95.486" gradientUnits="userSpaceOnUse" x2="320.04" gradientTransform="matrix(.52747 0 0 .50002 -156.81 -24.744)" y1="85.486" x1="320.04">
-   <stop id="stop6339" style="stop-color:#787878" offset="0"/>
-   <stop id="stop6341" style="stop-color:#bebebe" offset=".28718"/>
-   <stop id="stop6343" style="stop-color:#c8c8c8" offset=".42337"/>
-   <stop id="stop6345" style="stop-color:#fafafa" offset=".58038"/>
-   <stop id="stop6347" style="stop-color:#8c8c8c" offset="1"/>
-  </linearGradient>
-  <linearGradient id="linearGradient5549" y2="44.487" gradientUnits="userSpaceOnUse" x2="22.124" gradientTransform="matrix(.52937 0 0 .49994 -.71176 .75903)" y1="34.486" x1="22.124">
-   <stop id="stop6351" style="stop-color:#505050" offset="0"/>
-   <stop id="stop6353" style="stop-color:#a0a0a0" offset=".29325"/>
-   <stop id="stop6355" style="stop-color:#aaa" offset=".41122"/>
-   <stop id="stop6357" style="stop-color:#dcdcdc" offset=".59180"/>
-   <stop id="stop6359" style="stop-color:#6e6e6e" offset="1"/>
-  </linearGradient>
-  <radialGradient id="radialGradient5552" gradientUnits="userSpaceOnUse" cy="73.616" cx="6.7027" gradientTransform="matrix(1.1067 0 0 .20751 4.5818 7.2237)" r="7.2284">
-   <stop id="stop10693" offset="0"/>
-   <stop id="stop10695" style="stop-opacity:0" offset="1"/>
-  </radialGradient>
- </defs>
- <path id="path2589" style="opacity:.35;fill:url(#radialGradient5552)" d="m20 22.5c0 0.828-3.582 1.5-8 1.5-4.4183 0-8-0.672-8-1.5s3.5817-1.5 8-1.5 8 0.67157 8 1.5z"/>
- <path id="path4675" style="stroke-linejoin:round;stroke-dashoffset:0.5;stroke:url(#linearGradient5549);stroke-linecap:round;enable-background:new;fill:url(#linearGradient5547)" d="m9.5 16.507v3.5001c-0.011657 0.90102-1.4136 1.5-1.4136 1.5-0.39632 0.04422-0.5934 0.22301-0.5934 0.50002s0.26681 0.50002 0.5934 0.50002h7.8134c0.3266 0 0.5934-0.22301 0.5934-0.50002s-0.19709-0.4558-0.5934-0.50002c0 0-1.3881-0.59903-1.3998-1.5v-3.5001h-5z"/>
- <rect id="rect2722" style="stroke-linejoin:round;stroke-dashoffset:0.5;stroke:#b4b4b4;stroke-linecap:round;stroke-width:.99995;fill:url(#linearGradient5543)" height="17" width="23" y="1.5" x=".49997"/>
- <rect id="rect4642" style="stroke-linejoin:round;stroke-width:.99996;stroke-dashoffset:0.5;stroke:url(#radialGradient5540);stroke-linecap:round;enable-background:new;fill:none" rx="0" ry="0" height="15" width="21" y="2.5" x="1.5"/>
- <rect id="rect2716" style="stroke-width:.99959;fill-rule:evenodd;stroke:url(#linearGradient5778);enable-background:new;fill:url(#radialGradient5776)" height="13" width="19" y="3.4998" x="2.4998"/>
- <path id="rect6588" style="fill:url(#linearGradient5773)" d="m3 4h18v4.2667l-18 3.7333v-8z"/>
- <path id="path4319" style="stroke-linejoin:round;fill-rule:evenodd;stroke:#a38503;stroke-width:.49326;fill:url(#linearGradient5770)" d="m2.2466 3.2466v13.507h17.507l-17.507-13.507zm2.6534 5.5028l7.0726 5.5028h-7.0726v-5.5028z"/>
-</svg>
diff --git a/panels/display/icons/48x48/unity-display-panel.svg b/panels/display/icons/48x48/unity-display-panel.svg
deleted file mode 100644
index aed1893..0000000
--- a/panels/display/icons/48x48/unity-display-panel.svg
+++ /dev/null
@@ -1,70 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-<svg id="svg2" xmlns="http://www.w3.org/2000/svg" height="48" width="48" version="1.0" xmlns:xlink="http://www.w3.org/1999/xlink">
- <defs id="defs4">
-  <linearGradient id="linearGradient6602">
-   <stop id="stop6604" style="stop-color:#fff" offset="0"/>
-   <stop id="stop6606" style="stop-color:#fff;stop-opacity:0" offset="1"/>
-  </linearGradient>
-  <radialGradient id="radialGradient5540" gradientUnits="userSpaceOnUse" cy="15.064" cx="9.0262" gradientTransform="matrix(1.2852 -1.5925e-8 0 .95593 -5.5668 -3.082)" r="18.259">
-   <stop id="stop6567" style="stop-color:#fff" offset="0"/>
-   <stop id="stop6569" style="stop-color:#fff;stop-opacity:0" offset="1"/>
-  </radialGradient>
-  <linearGradient id="linearGradient5548" y2="41.181" gradientUnits="userSpaceOnUse" x2="25.208" gradientTransform="matrix(.92308 0 0 0.9 .34619 -6.6499)" y1="28.5" x1="13.63">
-   <stop id="stop7027" style="stop-color:#e6ce46" offset="0"/>
-   <stop id="stop7029" style="stop-color:#d6ba1c" offset="1"/>
-  </linearGradient>
-  <linearGradient id="linearGradient5551" y2="19.812" gradientUnits="userSpaceOnUse" x2="15.25" gradientTransform="matrix(.90476 0 0 1.2 2.2857 2.4)" y1="8.4375" x1="12.938">
-   <stop id="stop6594" style="stop-color:#fff;stop-opacity:.27451" offset="0"/>
-   <stop id="stop6596" style="stop-color:#fff;stop-opacity:0" offset="1"/>
-  </linearGradient>
-  <radialGradient id="radialGradient5554" gradientUnits="userSpaceOnUse" cy="4.8631" cx="12.244" gradientTransform="matrix(1.3156 .019277 -.012249 1.0776 -3.2306 6.0779)" r="21">
-   <stop id="stop6714" style="stop-color:#3c3c3c" offset="0"/>
-   <stop id="stop6716" style="stop-color:#1e1e1e" offset="1"/>
-  </radialGradient>
-  <linearGradient id="linearGradient5556" y2="3" gradientUnits="userSpaceOnUse" x2="25" gradientTransform="matrix(.95121 0 0 1.08 1.171 1.7202)" y1="29" x1="24.875">
-   <stop id="stop6720" style="stop-color:#141414" offset="0"/>
-   <stop id="stop6722" style="stop-color:#3c3c3c" offset="1"/>
-  </linearGradient>
-  <radialGradient id="radialGradient5559" xlink:href="#linearGradient6602" gradientUnits="userSpaceOnUse" cy="5.5643" cx="1" gradientTransform="matrix(.95555 0 0 .69715 1.0668 7.8457)" r="23"/>
-  <linearGradient id="linearGradient5562" y2="31.983" gradientUnits="userSpaceOnUse" x2="20.104" gradientTransform="matrix(0.959 0 0 1.0656 .98368 1.9503)" y1="-.00049710" x1="20.147">
-   <stop id="stop6546" style="stop-color:#f0f0f0" offset="0"/>
-   <stop id="stop6548" style="stop-color:#d2d2d2" offset="1"/>
-  </linearGradient>
-  <radialGradient id="radialGradient5565" xlink:href="#linearGradient6602" gradientUnits="userSpaceOnUse" cy="38.641" cx="24" gradientTransform="matrix(1.8286 -3.144e-8 0 .43815 -19.887 26.069)" r="8"/>
-  <linearGradient id="linearGradient5568" y2="93.38" gradientUnits="userSpaceOnUse" x2="320.28" gradientTransform="matrix(.99641 0 0 1.0001 -294.88 -51.013)" y1="86.913" x1="320.28">
-   <stop id="stop6622" style="stop-color:#787878" offset="0"/>
-   <stop id="stop6624" style="stop-color:#bebebe" offset=".35047"/>
-   <stop id="stop6626" style="stop-color:#c8c8c8" offset=".58327"/>
-   <stop id="stop6628" style="stop-color:#e6e6e6" offset=".72270"/>
-   <stop id="stop6630" style="stop-color:#8c8c8c" offset="1"/>
-  </linearGradient>
-  <linearGradient id="linearGradient5570" y2="42.361" gradientUnits="userSpaceOnUse" x2="21.686" y1="35.909" x1="21.718">
-   <stop id="stop6734" style="stop-color:#505050" offset="0"/>
-   <stop id="stop6736" style="stop-color:#a0a0a0" offset=".35047"/>
-   <stop id="stop6738" style="stop-color:#aaa" offset=".58327"/>
-   <stop id="stop6740" style="stop-color:#bebebe" offset=".72270"/>
-   <stop id="stop6742" style="stop-color:#6e6e6e" offset="1"/>
-  </linearGradient>
-  <radialGradient id="radialGradient5573" gradientUnits="userSpaceOnUse" cy="73.616" cx="6.7027" gradientTransform="matrix(1.9368 0 0 .41503 11.018 12.447)" r="7.2284">
-   <stop id="stop10693" offset="0"/>
-   <stop id="stop10695" style="stop-opacity:0" offset="1"/>
-  </radialGradient>
- </defs>
- <g id="g6347">
-  <path id="path2589" style="opacity:.5;fill:url(#radialGradient5573)" d="m38 43c0 1.6569-6.268 3-14 3s-14-1.343-14-3 6.268-3 14-3 14 1.343 14 3z"/>
-  <path id="path4675" style="stroke-linejoin:round;stroke-width:.99827;stroke-dashoffset:0.5;stroke:url(#linearGradient5570);stroke-linecap:round;enable-background:new;fill:url(#linearGradient5568)" d="m18.489 31.499v7.001c-0.02202 1.8022-1.8685 3.0004-1.8685 3.0004-0.74866 0.08844-1.121 0.44607-1.121 1.0002 0 0.55408 0.50401 1.0001 1.121 1.0001h14.76c0.61695 0 1.121-0.44606 1.121-1.0001 0-0.55408-0.3723-0.91171-1.121-1.0002 0 0-1.8465-1.1982-1.8685-3.0004v-7.001h-11.023z"/>
-  <rect id="rect4703" style="opacity:.8;enable-background:new;fill:url(#radialGradient5565)" rx=".44444" ry="0.5" height="1" width="16" y="42" x="16"/>
-  <rect id="rect2722" style="stroke-linejoin:round;stroke-dashoffset:0.5;stroke:#aaa;stroke-linecap:round;stroke-width:1.0002;fill:url(#linearGradient5562)" rx="1" ry="1" height="33" width="45" y="2.5001" x="1.5001"/>
-  <rect id="rect4642" style="stroke-linejoin:round;stroke-width:1.0003;stroke-dashoffset:0.5;stroke:url(#radialGradient5559);stroke-linecap:round;enable-background:new;fill:none" rx="0" ry="0" height="31" width="43" y="3.5001" x="2.5001"/>
-  <rect id="rect2716" style="stroke-linejoin:round;stroke-width:1.0004;fill-rule:evenodd;stroke:url(#linearGradient5556);enable-background:new;fill:url(#radialGradient5554)" height="27" width="39" y="5.5002" x="4.5002"/>
-  <path id="rect6588" style="fill:url(#linearGradient5551)" d="m5 6h38v9.6l-38 8.4v-18z"/>
-  <path id="path4319" style="stroke-linejoin:round;fill-rule:evenodd;stroke:#a38503;stroke-width:1.0001;fill:url(#linearGradient5548)" d="m4.5 5.5v27h36l-36-27zm5 11l15 11h-15v-11z"/>
-  <path id="path4326" style="stroke-linejoin:round;stroke:#a38503;stroke-linecap:round;stroke-width:.99969;fill:none" d="m9.4998 32.5v-2.0003"/>
-  <path id="path4328" style="stroke-linejoin:round;stroke:#a38503;stroke-linecap:round;stroke-width:.99969;fill:none" d="m14.5 32.5v-2.0003"/>
-  <path id="path4330" style="stroke-linejoin:round;stroke:#a38503;stroke-linecap:round;stroke-width:.99969;fill:none" d="m19.5 32.5v-1.9765"/>
-  <path id="path4332" style="stroke-linejoin:round;stroke:#a38503;stroke-linecap:round;stroke-width:.99969;fill:none" d="m24.5 32.5v-2.0003"/>
-  <path id="path4334" style="stroke-linejoin:round;stroke:#a38503;stroke-linecap:round;stroke-width:.99969;fill:none" d="m29.5 32.5v-2.0003"/>
-  <path id="path14994" style="opacity:.5;stroke-linejoin:round;stroke:url(#radialGradient5540);stroke-width:1.0004;fill:none" d="m5.5002 7.5002v24h32l-32-24zm4.9998 8.4998 14.5 10.5c0.546 0.39538 0.37406 2-0.30006 2h-14.612c-0.7225 0-1.588-0.752-1.588-1.474v-9.7075c0-0.671 1.4561-1.712 2-1.318z"/>
- </g>
-</svg>
diff --git a/panels/display/scrollarea.c b/panels/display/scrollarea.c
deleted file mode 100644
index 995872d..0000000
--- a/panels/display/scrollarea.c
+++ /dev/null
@@ -1,1573 +0,0 @@
-/* Copyright 2006, 2007, 2008, Soren Sandmann <sandmann@daimi.au.dk>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "scrollarea.h"
-
-#include <gdk/gdk.h>
-
-#include "foo-marshal.h"
-
-G_DEFINE_TYPE_WITH_CODE (FooScrollArea, foo_scroll_area, GTK_TYPE_CONTAINER,
-                         G_IMPLEMENT_INTERFACE (GTK_TYPE_SCROLLABLE, NULL));
-
-static GtkWidgetClass *parent_class;
-
-typedef struct BackingStore BackingStore;
-
-typedef struct InputPath InputPath;
-typedef struct InputRegion InputRegion;
-typedef struct AutoScrollInfo AutoScrollInfo;
-
-struct InputPath
-{
-  gboolean                    is_stroke;
-  cairo_fill_rule_t           fill_rule;
-  double                      line_width;
-  cairo_path_t               *path;           /* In canvas coordinates */
-
-  FooScrollAreaEventFunc      func;
-  gpointer                    data;
-
-  InputPath                  *next;
-};
-
-/* InputRegions are mutually disjoint */
-struct InputRegion
-{
-  /* the boundary of this area in canvas coordinates */
-  cairo_region_t *region;
-
-  InputPath *paths;
-};
-
-struct AutoScrollInfo
-{
-  int                         dx;
-  int                         dy;
-  int                         timeout_id;
-  int                         begin_x;
-  int                         begin_y;
-  double                      res_x;
-  double                      res_y;
-  GTimer                     *timer;
-};
-
-struct FooScrollAreaPrivate
-{
-  GdkWindow                  *input_window;
-
-  int                         width;
-  int                         height;
-
-  GtkAdjustment              *hadj;
-  GtkAdjustment              *vadj;
-  GtkScrollablePolicy         hscroll_policy;
-  GtkScrollablePolicy         vscroll_policy;
-  int                         x_offset;
-  int                         y_offset;
-
-  int                         min_width;
-  int                         min_height;
-
-  GPtrArray                  *input_regions;
-
-  AutoScrollInfo             *auto_scroll_info;
-
-  /* During expose, this region is set to the region
-   * being exposed. At other times, it is NULL
-   *
-   * It is used for clipping of input areas
-   */
-  InputRegion                *current_input;
-
-  gboolean                    grabbed;
-  FooScrollAreaEventFunc      grab_func;
-  gpointer                    grab_data;
-
-  cairo_surface_t            *surface;
-  cairo_region_t             *update_region; /* In canvas coordinates */
-};
-
-enum
-  {
-    VIEWPORT_CHANGED,
-    PAINT,
-    INPUT,
-    LAST_SIGNAL,
-  };
-
-enum {
-  PROP_0,
-  PROP_VADJUSTMENT,
-  PROP_HADJUSTMENT,
-  PROP_HSCROLL_POLICY,
-  PROP_VSCROLL_POLICY
-};
-
-static guint signals [LAST_SIGNAL] = { 0 };
-
-static gboolean foo_scroll_area_draw (GtkWidget *widget,
-                                      cairo_t *cr);
-static void foo_scroll_area_get_preferred_width (GtkWidget *widget,
-                                                 gint      *minimum,
-                                                 gint      *natural);
-static void foo_scroll_area_get_preferred_height (GtkWidget *widget,
-                                                  gint      *minimum,
-                                                  gint      *natural);
-static void foo_scroll_area_size_allocate (GtkWidget *widget,
-                                           GtkAllocation *allocation);
-static void foo_scroll_area_set_hadjustment (FooScrollArea *scroll_area,
-                                             GtkAdjustment *hadjustment);
-static void foo_scroll_area_set_vadjustment (FooScrollArea *scroll_area,
-                                             GtkAdjustment *vadjustment);
-static void foo_scroll_area_realize (GtkWidget *widget);
-static void foo_scroll_area_unrealize (GtkWidget *widget);
-static void foo_scroll_area_map (GtkWidget *widget);
-static void foo_scroll_area_unmap (GtkWidget *widget);
-static gboolean foo_scroll_area_button_press (GtkWidget *widget,
-                                              GdkEventButton *event);
-static gboolean foo_scroll_area_button_release (GtkWidget *widget,
-                                                GdkEventButton *event);
-static gboolean foo_scroll_area_motion (GtkWidget *widget,
-                                        GdkEventMotion *event);
-
-static void
-foo_scroll_area_map (GtkWidget *widget)
-{
-  FooScrollArea *area = FOO_SCROLL_AREA (widget);
-
-  GTK_WIDGET_CLASS (parent_class)->map (widget);
-
-  if (area->priv->input_window)
-    gdk_window_show (area->priv->input_window);
-}
-
-static void
-foo_scroll_area_unmap (GtkWidget *widget)
-{
-  FooScrollArea *area = FOO_SCROLL_AREA (widget);
-
-  if (area->priv->input_window)
-    gdk_window_hide (area->priv->input_window);
-
-  GTK_WIDGET_CLASS (parent_class)->unmap (widget);
-}
-
-static void
-foo_scroll_area_finalize (GObject *object)
-{
-  FooScrollArea *scroll_area = FOO_SCROLL_AREA (object);
-
-  g_object_unref (scroll_area->priv->hadj);
-  g_object_unref (scroll_area->priv->vadj);
-
-  g_ptr_array_free (scroll_area->priv->input_regions, TRUE);
-
-  g_free (scroll_area->priv);
-
-  G_OBJECT_CLASS (foo_scroll_area_parent_class)->finalize (object);
-}
-
-static void
-foo_scroll_area_get_property (GObject    *object,
-                              guint       property_id,
-                              GValue     *value,
-                              GParamSpec *pspec)
-{
-  FooScrollArea *scroll_area = FOO_SCROLL_AREA (object);
-
-  switch (property_id)
-    {
-    case PROP_VADJUSTMENT:
-      g_value_set_object (value, &scroll_area->priv->vadj);
-      break;
-    case PROP_HADJUSTMENT:
-      g_value_set_object (value, &scroll_area->priv->hadj);
-      break;
-    case PROP_HSCROLL_POLICY:
-      g_value_set_enum (value, scroll_area->priv->hscroll_policy);
-      break;
-    case PROP_VSCROLL_POLICY:
-      g_value_set_enum (value, scroll_area->priv->vscroll_policy);
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-    }
-}
-
-static void
-foo_scroll_area_set_property (GObject      *object,
-                              guint         property_id,
-                              const GValue *value,
-                              GParamSpec   *pspec)
-{
-  FooScrollArea *scroll_area = FOO_SCROLL_AREA (object);
-
-  switch (property_id) {
-  case PROP_VADJUSTMENT:
-    foo_scroll_area_set_vadjustment (FOO_SCROLL_AREA (object), g_value_get_object (value));
-    break;
-  case PROP_HADJUSTMENT:
-    foo_scroll_area_set_hadjustment (FOO_SCROLL_AREA (object), g_value_get_object (value));
-    break;
-  case PROP_HSCROLL_POLICY:
-    scroll_area->priv->hscroll_policy = g_value_get_enum (value);
-    break;
-  case PROP_VSCROLL_POLICY:
-    scroll_area->priv->vscroll_policy = g_value_get_enum (value);
-    break;
-  default:
-    G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-  }
-}
-
-static void
-foo_scroll_area_class_init (FooScrollAreaClass *class)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (class);
-  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (class);
-
-  object_class->finalize = foo_scroll_area_finalize;
-  object_class->set_property = foo_scroll_area_set_property;
-  object_class->get_property = foo_scroll_area_get_property;
-
-  widget_class->get_preferred_width = foo_scroll_area_get_preferred_width;
-  widget_class->get_preferred_height = foo_scroll_area_get_preferred_height;
-  widget_class->draw = foo_scroll_area_draw;
-  widget_class->size_allocate = foo_scroll_area_size_allocate;
-  widget_class->realize = foo_scroll_area_realize;
-  widget_class->unrealize = foo_scroll_area_unrealize;
-  widget_class->button_press_event = foo_scroll_area_button_press;
-  widget_class->button_release_event = foo_scroll_area_button_release;
-  widget_class->motion_notify_event = foo_scroll_area_motion;
-  widget_class->map = foo_scroll_area_map;
-  widget_class->unmap = foo_scroll_area_unmap;
-
-  parent_class = g_type_class_peek_parent (class);
-
-  /* Scrollable interface properties */
-  g_object_class_override_property (object_class, PROP_HADJUSTMENT, "hadjustment");
-  g_object_class_override_property (object_class, PROP_VADJUSTMENT, "vadjustment");
-  g_object_class_override_property (object_class, PROP_HSCROLL_POLICY, "hscroll-policy");
-  g_object_class_override_property (object_class, PROP_VSCROLL_POLICY, "vscroll-policy");
-
-  signals[VIEWPORT_CHANGED] =
-    g_signal_new ("viewport_changed",
-                  G_OBJECT_CLASS_TYPE (object_class),
-                  G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-                  G_STRUCT_OFFSET (FooScrollAreaClass,
-                                   viewport_changed),
-                  NULL, NULL,
-                  foo_marshal_VOID__BOXED_BOXED,
-                  G_TYPE_NONE, 2,
-                  GDK_TYPE_RECTANGLE,
-                  GDK_TYPE_RECTANGLE);
-
-  signals[PAINT] =
-    g_signal_new ("paint",
-                  G_OBJECT_CLASS_TYPE (object_class),
-                  G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-                  G_STRUCT_OFFSET (FooScrollAreaClass,
-                                   paint),
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__POINTER,
-                  G_TYPE_NONE, 1,
-                  G_TYPE_POINTER);
-}
-
-static GtkAdjustment *
-new_adjustment (void)
-{
-  return GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
-}
-
-static void
-foo_scroll_area_init (FooScrollArea *scroll_area)
-{
-  GtkWidget *widget;
-
-  widget = GTK_WIDGET (scroll_area);
-
-  gtk_widget_set_has_window (widget, FALSE);
-  gtk_widget_set_redraw_on_allocate (widget, FALSE);
-
-  scroll_area->priv = g_new0 (FooScrollAreaPrivate, 1);
-  scroll_area->priv->width = 0;
-  scroll_area->priv->height = 0;
-  scroll_area->priv->hadj = g_object_ref_sink (new_adjustment());
-  scroll_area->priv->vadj = g_object_ref_sink (new_adjustment());
-  scroll_area->priv->x_offset = 0.0;
-  scroll_area->priv->y_offset = 0.0;
-  scroll_area->priv->min_width = 0;
-  scroll_area->priv->min_height = 0;
-  scroll_area->priv->auto_scroll_info = NULL;
-  scroll_area->priv->input_regions = g_ptr_array_new ();
-  scroll_area->priv->surface = NULL;
-  scroll_area->priv->update_region = cairo_region_create ();
-}
-
-typedef void (* PathForeachFunc) (double  *x,
-                                  double  *y,
-                                  gpointer data);
-
-static void
-path_foreach_point (cairo_path_t     *path,
-                    PathForeachFunc   func,
-                    gpointer          user_data)
-{
-  int i;
-
-  for (i = 0; i < path->num_data; i += path->data[i].header.length)
-    {
-      cairo_path_data_t *data = &(path->data[i]);
-
-      switch (data->header.type)
-        {
-        case CAIRO_PATH_MOVE_TO:
-        case CAIRO_PATH_LINE_TO:
-          func (&(data[1].point.x), &(data[1].point.y), user_data);
-          break;
-
-        case CAIRO_PATH_CURVE_TO:
-          func (&(data[1].point.x), &(data[1].point.y), user_data);
-          func (&(data[2].point.x), &(data[2].point.y), user_data);
-          func (&(data[3].point.x), &(data[3].point.y), user_data);
-          break;
-
-        case CAIRO_PATH_CLOSE_PATH:
-          break;
-        }
-    }
-}
-
-typedef struct
-{
-  double x1, y1, x2, y2;
-} Box;
-
-static void
-input_path_free_list (InputPath *paths)
-{
-  if (!paths)
-    return;
-
-  input_path_free_list (paths->next);
-  cairo_path_destroy (paths->path);
-  g_free (paths);
-}
-
-static void
-input_region_free (InputRegion *region)
-{
-  input_path_free_list (region->paths);
-  cairo_region_destroy (region->region);
-
-  g_free (region);
-}
-
-static void
-get_viewport (FooScrollArea *scroll_area,
-              GdkRectangle  *viewport)
-{
-  GtkAllocation allocation;
-  GtkWidget *widget = GTK_WIDGET (scroll_area);
-
-  gtk_widget_get_allocation (widget, &allocation);
-
-  viewport->x = scroll_area->priv->x_offset;
-  viewport->y = scroll_area->priv->y_offset;
-  viewport->width = allocation.width;
-  viewport->height = allocation.height;
-}
-
-static void
-allocation_to_canvas (FooScrollArea *area,
-                      int           *x,
-                      int           *y)
-{
-  *x += area->priv->x_offset;
-  *y += area->priv->y_offset;
-}
-
-static void
-clear_exposed_input_region (FooScrollArea  *area,
-                            cairo_region_t *exposed) /* in canvas coordinates */
-{
-  int i;
-  cairo_region_t *viewport;
-  GdkRectangle allocation;
-
-  gtk_widget_get_allocation (GTK_WIDGET (area), &allocation);
-  allocation.x = 0;
-  allocation.y = 0;
-  allocation_to_canvas (area, &allocation.x, &allocation.y);
-
-  viewport = cairo_region_create_rectangle (&allocation);
-  cairo_region_subtract (viewport, exposed);
-
-  for (i = 0; i < area->priv->input_regions->len; ++i)
-    {
-      InputRegion *region = area->priv->input_regions->pdata[i];
-
-      cairo_region_intersect (region->region, viewport);
-
-      if (cairo_region_is_empty (region->region))
-        {
-          input_region_free (region);
-          g_ptr_array_remove_index_fast (area->priv->input_regions, i--);
-        }
-    }
-
-  cairo_region_destroy (viewport);
-}
-
-/* taken from mutter */
-static void
-setup_background_cr (GdkWindow *window, cairo_t *cr, int x_offset, int y_offset)
-{
-  GdkWindow *parent = gdk_window_get_parent (window);
-  cairo_pattern_t *bg_pattern;
-
-  bg_pattern = gdk_window_get_background_pattern (window);
-  if (bg_pattern == NULL && parent)
-    {
-      gint window_x, window_y;
-
-      gdk_window_get_position (window, &window_x, &window_y);
-      setup_background_cr (parent, cr, x_offset + window_x, y_offset + window_y);
-    }
-  else if (bg_pattern)
-    {
-      cairo_translate (cr, - x_offset, - y_offset);
-      cairo_set_source (cr, bg_pattern);
-      cairo_translate (cr, x_offset, y_offset);
-    }
-}
-
-static void
-initialize_background (GtkWidget *widget,
-                       cairo_t   *cr)
-{
-  setup_background_cr (gtk_widget_get_window (widget), cr, 0, 0);
-
-  cairo_paint (cr);
-}
-
-static gboolean
-foo_scroll_area_draw (GtkWidget *widget,
-                      cairo_t   *cr)
-{
-  FooScrollArea *scroll_area = FOO_SCROLL_AREA (widget);
-  cairo_region_t *region;
-  GtkAllocation widget_allocation;
-
-  /* Note that this function can be called at a time
-   * where the adj->value is different from x_offset.
-   * Ie., the GtkScrolledWindow changed the adj->value
-   * without emitting the value_changed signal.
-   *
-   * Hence we must always use the value we got
-   * the last time the signal was emitted, ie.,
-   * priv->{x,y}_offset.
-   */
-
-  /* Setup input areas */
-  clear_exposed_input_region (scroll_area, scroll_area->priv->update_region);
-
-  scroll_area->priv->current_input = g_new0 (InputRegion, 1);
-  scroll_area->priv->current_input->region = cairo_region_copy (scroll_area->priv->update_region);
-  scroll_area->priv->current_input->paths = NULL;
-  g_ptr_array_add (scroll_area->priv->input_regions,
-                   scroll_area->priv->current_input);
-
-  region = scroll_area->priv->update_region;
-  scroll_area->priv->update_region = cairo_region_create ();
-
-  initialize_background (widget, cr);
-
-  g_signal_emit (widget, signals[PAINT], 0, cr);
-
-  scroll_area->priv->current_input = NULL;
-
-  gtk_widget_get_allocation (widget, &widget_allocation);
-
-  /* Finally draw the backing surface */
-  cairo_set_source_surface (cr, scroll_area->priv->surface,
-                            widget_allocation.x, widget_allocation.y);
-  cairo_fill (cr);
-
-  cairo_region_destroy (region);
-
-  return TRUE;
-}
-
-void
-foo_scroll_area_get_viewport (FooScrollArea *scroll_area,
-                              GdkRectangle  *viewport)
-{
-  g_return_if_fail (FOO_IS_SCROLL_AREA (scroll_area));
-
-  if (!viewport)
-    return;
-
-  get_viewport (scroll_area, viewport);
-}
-
-static void
-process_event (FooScrollArea           *scroll_area,
-               FooScrollAreaEventType   input_type,
-               int                      x,
-               int                      y);
-
-static void
-emit_viewport_changed (FooScrollArea *scroll_area,
-                       GdkRectangle  *new_viewport,
-                       GdkRectangle  *old_viewport)
-{
-  int px, py;
-  g_signal_emit (scroll_area, signals[VIEWPORT_CHANGED], 0,
-                 new_viewport, old_viewport);
-
-  if (scroll_area->priv->input_window == NULL)
-    return;
-
-  gdk_window_get_pointer (scroll_area->priv->input_window, &px, &py, NULL);
-
-#if 0
-  g_print ("procc\n");
-#endif
-
-  process_event (scroll_area, FOO_MOTION, px, py);
-}
-
-static void
-clamp_adjustment (GtkAdjustment *adj)
-{
-  if (gtk_adjustment_get_upper (adj) >= gtk_adjustment_get_page_size (adj))
-    gtk_adjustment_set_value (adj, CLAMP (gtk_adjustment_get_value (adj), 0.0,
-                                          gtk_adjustment_get_upper (adj)
-                                          - gtk_adjustment_get_page_size (adj)));
-  else
-    gtk_adjustment_set_value (adj, 0.0);
-
-  gtk_adjustment_changed (adj);
-}
-
-static gboolean
-set_adjustment_values (FooScrollArea *scroll_area)
-{
-  GtkAllocation allocation;
-
-  GtkAdjustment *hadj = scroll_area->priv->hadj;
-  GtkAdjustment *vadj = scroll_area->priv->vadj;
-
-  /* Horizontal */
-  gtk_widget_get_allocation (GTK_WIDGET (scroll_area), &allocation);
-  g_object_freeze_notify (G_OBJECT (hadj));
-  gtk_adjustment_set_page_size (hadj, allocation.width);
-  gtk_adjustment_set_step_increment (hadj, 0.1 * allocation.width);
-  gtk_adjustment_set_page_increment (hadj, 0.9 * allocation.width);
-  gtk_adjustment_set_lower (hadj, 0.0);
-  gtk_adjustment_set_upper (hadj, scroll_area->priv->width);
-  g_object_thaw_notify (G_OBJECT (hadj));
-
-  /* Vertical */
-  g_object_freeze_notify (G_OBJECT (vadj));
-  gtk_adjustment_set_page_size (vadj, allocation.height);
-  gtk_adjustment_set_step_increment (vadj, 0.1 * allocation.height);
-  gtk_adjustment_set_page_increment (vadj, 0.9 * allocation.height);
-  gtk_adjustment_set_lower (vadj, 0.0);
-  gtk_adjustment_set_upper (vadj, scroll_area->priv->height);
-  g_object_thaw_notify (G_OBJECT (vadj));
-
-  clamp_adjustment (hadj);
-  clamp_adjustment (vadj);
-
-  return TRUE;
-}
-
-static void
-foo_scroll_area_realize (GtkWidget *widget)
-{
-  FooScrollArea *area = FOO_SCROLL_AREA (widget);
-  GdkWindowAttr attributes;
-  GtkAllocation widget_allocation;
-  GdkWindow *window;
-  gint attributes_mask;
-  cairo_t *cr;
-
-  gtk_widget_get_allocation (widget, &widget_allocation);
-  gtk_widget_set_realized (widget, TRUE);
-
-  attributes.window_type = GDK_WINDOW_CHILD;
-  attributes.x = widget_allocation.x;
-  attributes.y = widget_allocation.y;
-  attributes.width = widget_allocation.width;
-  attributes.height = widget_allocation.height;
-  attributes.wclass = GDK_INPUT_ONLY;
-  attributes.event_mask = gtk_widget_get_events (widget);
-  attributes.event_mask |= (GDK_BUTTON_PRESS_MASK |
-                            GDK_BUTTON_RELEASE_MASK |
-                            GDK_BUTTON1_MOTION_MASK |
-                            GDK_BUTTON2_MOTION_MASK |
-                            GDK_BUTTON3_MOTION_MASK |
-                            GDK_POINTER_MOTION_MASK |
-                            GDK_ENTER_NOTIFY_MASK |
-                            GDK_LEAVE_NOTIFY_MASK);
-
-  attributes_mask = GDK_WA_X | GDK_WA_Y;
-
-  window = gtk_widget_get_parent_window (widget);
-  gtk_widget_set_window (widget, window);
-  g_object_ref (window);
-
-  area->priv->input_window = gdk_window_new (window,
-                                             &attributes, attributes_mask);
-
-  cr = gdk_cairo_create (gtk_widget_get_window (widget));
-  area->priv->surface = cairo_surface_create_similar (cairo_get_target (cr),
-                                                      CAIRO_CONTENT_COLOR,
-                                                      widget_allocation.width,
-                                                      widget_allocation.height);
-  cairo_destroy (cr);
-
-  gdk_window_set_user_data (area->priv->input_window, area);
-}
-
-static void
-foo_scroll_area_unrealize (GtkWidget *widget)
-{
-  FooScrollArea *area = FOO_SCROLL_AREA (widget);
-
-  if (area->priv->input_window)
-    {
-      gdk_window_set_user_data (area->priv->input_window, NULL);
-      gdk_window_destroy (area->priv->input_window);
-      area->priv->input_window = NULL;
-    }
-
-  GTK_WIDGET_CLASS (parent_class)->unrealize (widget);
-}
-
-static cairo_surface_t *
-create_new_surface (GtkWidget *widget,
-                    cairo_surface_t *old)
-{
-  GtkAllocation widget_allocation;
-  cairo_surface_t *new;
-  cairo_t *cr;
-
-  gtk_widget_get_allocation (widget, &widget_allocation);
-  cr = gdk_cairo_create (gtk_widget_get_window (widget));
-  new = cairo_surface_create_similar (cairo_get_target (cr),
-                                      CAIRO_CONTENT_COLOR,
-                                      widget_allocation.width,
-                                      widget_allocation.height);
-  cairo_destroy (cr);
-
-  /* Unfortunately we don't know in which direction we were resized,
-   * so we just assume we were dragged from the south-east corner.
-   *
-   * Although, maybe we could get the root coordinates of the input-window?
-   * That might just work, actually. We need to make sure metacity uses
-   * static gravity for the window before this will be useful.
-   */
-  cr = cairo_create (new);
-  cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
-  cairo_set_source_surface (cr, old, 0, 0);
-  cairo_paint (cr);
-  cairo_destroy (cr);
-
-  return new;
-}
-
-static void
-allocation_to_canvas_region (FooScrollArea  *area,
-                             cairo_region_t *region)
-{
-  cairo_region_translate (region, area->priv->x_offset, area->priv->y_offset);
-}
-
-static void
-_cairo_region_xor (cairo_region_t       *dst,
-                   const cairo_region_t *src)
-{
-  cairo_region_t *trb;
-
-  trb = cairo_region_copy (src);
-
-  cairo_region_subtract (trb, dst);
-  cairo_region_subtract (dst, src);
-
-  cairo_region_union (dst, trb);
-
-  cairo_region_destroy (trb);
-}
-
-static void
-foo_scroll_area_size_allocate (GtkWidget     *widget,
-                               GtkAllocation *allocation)
-{
-  FooScrollArea *scroll_area = FOO_SCROLL_AREA (widget);
-  GdkRectangle new_viewport;
-  GdkRectangle old_viewport;
-  cairo_region_t *old_allocation;
-  cairo_region_t *invalid;
-  GtkAllocation widget_allocation;
-
-  get_viewport (scroll_area, &old_viewport);
-
-  gtk_widget_get_allocation (widget, &widget_allocation);
-
-  old_allocation = cairo_region_create_rectangle (&widget_allocation);
-  cairo_region_translate (old_allocation,
-                          -widget_allocation.x, -widget_allocation.y);
-
-  invalid = cairo_region_create_rectangle (allocation);
-  cairo_region_translate (invalid, -allocation->x, -allocation->y);
-  _cairo_region_xor (invalid, old_allocation);
-  allocation_to_canvas_region (scroll_area, invalid);
-  foo_scroll_area_invalidate_region (scroll_area, invalid);
-
-  cairo_region_destroy (old_allocation);
-  cairo_region_destroy (invalid);
-
-  gtk_widget_set_allocation (widget, allocation);
-
-  if (scroll_area->priv->input_window)
-    {
-      cairo_surface_t *new_surface;
-
-      gdk_window_move_resize (scroll_area->priv->input_window,
-                              allocation->x, allocation->y,
-                              allocation->width, allocation->height);
-
-      new_surface = create_new_surface (widget, scroll_area->priv->surface);
-      cairo_surface_destroy (scroll_area->priv->surface);
-
-      scroll_area->priv->surface = new_surface;
-    }
-
-  get_viewport (scroll_area, &new_viewport);
-
-  emit_viewport_changed (scroll_area, &new_viewport, &old_viewport);
-}
-
-static void
-emit_input (FooScrollArea *scroll_area,
-            FooScrollAreaEventType type,
-            int                    x,
-            int                    y,
-            FooScrollAreaEventFunc func,
-            gpointer            data)
-{
-  FooScrollAreaEvent event;
-
-  if (!func)
-    return;
-
-  event.type = type;
-  event.x = x;
-  event.y = y;
-
-  func (scroll_area, &event, data);
-}
-
-static void
-process_event (FooScrollArea           *scroll_area,
-               FooScrollAreaEventType   input_type,
-               int                      x,
-               int                      y)
-{
-  GtkWidget *widget = GTK_WIDGET (scroll_area);
-  int i;
-
-  allocation_to_canvas (scroll_area, &x, &y);
-
-  if (scroll_area->priv->grabbed)
-    {
-      emit_input (scroll_area, input_type, x, y,
-                  scroll_area->priv->grab_func,
-                  scroll_area->priv->grab_data);
-    }
-
-#if 0
-  g_print ("number of input regions: %d\n", scroll_area->priv->input_regions->len);
-#endif
-
-  for (i = 0; i < scroll_area->priv->input_regions->len; ++i)
-    {
-      InputRegion *region = scroll_area->priv->input_regions->pdata[i];
-
-#if 0
-      g_print ("region %d (looking for %d,%d) ", i, x, y);
-#endif
-
-      if (cairo_region_contains_point (region->region, x, y))
-        {
-          InputPath *path;
-
-          path = region->paths;
-          while (path)
-            {
-              cairo_t *cr;
-              gboolean inside;
-
-              cr = gdk_cairo_create (gtk_widget_get_window (widget));
-              cairo_set_fill_rule (cr, path->fill_rule);
-              cairo_set_line_width (cr, path->line_width);
-              cairo_append_path (cr, path->path);
-
-              if (path->is_stroke)
-                inside = cairo_in_stroke (cr, x, y);
-              else
-                inside = cairo_in_fill (cr, x, y);
-
-              cairo_destroy (cr);
-
-              if (inside)
-                {
-                  if (scroll_area->priv->grabbed)
-                    {
-                      emit_input (scroll_area, FOO_DRAG_HOVER,
-                                  x, y,
-                                  path->func,
-                                  path->data);
-                    }
-                  else
-                    {
-                      emit_input (scroll_area, input_type,
-                                  x, y,
-                                  path->func,
-                                  path->data);
-                    }
-                  return;
-                }
-
-              path = path->next;
-            }
-
-          /* Since the regions are all disjoint, no other region
-           * can match. Of course we could be clever and try and
-           * sort the regions, but so far I have been unable to
-           * make this loop show up on a profile.
-           */
-          return;
-        }
-    }
-}
-
-static void
-process_gdk_event (FooScrollArea *scroll_area,
-                   int            x,
-                   int            y,
-                   GdkEvent      *event)
-{
-  FooScrollAreaEventType input_type;
-
-  if (event->type == GDK_BUTTON_PRESS)
-    input_type = FOO_BUTTON_PRESS;
-  else if (event->type == GDK_BUTTON_RELEASE)
-    input_type = FOO_BUTTON_RELEASE;
-  else if (event->type == GDK_MOTION_NOTIFY)
-    input_type = FOO_MOTION;
-  else
-    return;
-
-  process_event (scroll_area, input_type, x, y);
-}
-
-static gboolean
-foo_scroll_area_button_press (GtkWidget *widget,
-                              GdkEventButton *event)
-{
-  FooScrollArea *area = FOO_SCROLL_AREA (widget);
-
-  process_gdk_event (area, event->x, event->y, (GdkEvent *)event);
-
-  return TRUE;
-}
-
-static gboolean
-foo_scroll_area_button_release (GtkWidget *widget,
-                                GdkEventButton *event)
-{
-  FooScrollArea *area = FOO_SCROLL_AREA (widget);
-
-  process_gdk_event (area, event->x, event->y, (GdkEvent *)event);
-
-  return FALSE;
-}
-
-static gboolean
-foo_scroll_area_motion (GtkWidget *widget,
-                        GdkEventMotion *event)
-{
-  FooScrollArea *area = FOO_SCROLL_AREA (widget);
-
-  process_gdk_event (area, event->x, event->y, (GdkEvent *)event);
-  return TRUE;
-}
-
-void
-foo_scroll_area_set_size_fixed_y (FooScrollArea        *scroll_area,
-                                  int                   width,
-                                  int                   height,
-                                  int                   old_y,
-                                  int                   new_y)
-{
-  scroll_area->priv->width = width;
-  scroll_area->priv->height = height;
-
-#if 0
-  g_print ("diff: %d\n", new_y - old_y);
-#endif
-  g_object_thaw_notify (G_OBJECT (scroll_area->priv->vadj));
-  gtk_adjustment_set_value (scroll_area->priv->vadj, new_y);
-
-  set_adjustment_values (scroll_area);
-  g_object_thaw_notify (G_OBJECT (scroll_area->priv->vadj));
-}
-
-void
-foo_scroll_area_set_size (FooScrollArea        *scroll_area,
-                          int                   width,
-                          int                   height)
-{
-  g_return_if_fail (FOO_IS_SCROLL_AREA (scroll_area));
-
-  /* FIXME: Default scroll algorithm should probably be to
-   * keep the same *area* outside the screen as before.
-   *
-   * For wrapper widgets that will do something roughly
-   * right. For widgets that don't change size, it
-   * will do the right thing. Except for idle-layouting
-   * widgets.
-   *
-   * Maybe there should be some generic support for those
-   * widgets. Can that even be done?
-   *
-   * Should we have a version of this function using
-   * fixed points?
-   */
-
-  scroll_area->priv->width = width;
-  scroll_area->priv->height = height;
-
-  set_adjustment_values (scroll_area);
-}
-
-static void
-foo_scroll_area_get_preferred_width (GtkWidget *widget,
-                                     gint      *minimum,
-                                     gint      *natural)
-{
-  FooScrollArea *scroll_area = FOO_SCROLL_AREA (widget);
-
-  if (minimum != NULL) {
-    *minimum = scroll_area->priv->min_width;
-  }
-  if (natural != NULL) {
-    *natural = scroll_area->priv->min_width;
-  }
-}
-
-static void
-foo_scroll_area_get_preferred_height (GtkWidget *widget,
-                                      gint      *minimum,
-                                      gint      *natural)
-{
-  FooScrollArea *scroll_area = FOO_SCROLL_AREA (widget);
-
-  if (minimum != NULL) {
-    *minimum = scroll_area->priv->min_height;
-  }
-  if (natural != NULL) {
-    *natural = scroll_area->priv->min_height;
-  }
-}
-
-static void
-foo_scroll_area_scroll (FooScrollArea *area,
-                        gint dx,
-                        gint dy)
-{
-  GdkRectangle allocation;
-  GdkRectangle src_area;
-  GdkRectangle move_area;
-  cairo_region_t *invalid_region;
-
-  gtk_widget_get_allocation (GTK_WIDGET (area), &allocation);
-  allocation.x = 0;
-  allocation.y = 0;
-
-  src_area = allocation;
-  src_area.x -= dx;
-  src_area.y -= dy;
-
-  invalid_region = cairo_region_create_rectangle (&allocation);
-
-  if (gdk_rectangle_intersect (&allocation, &src_area, &move_area))
-    {
-      cairo_region_t *move_region;
-      cairo_t *cr;
-
-#if 0
-      g_print ("scrolling %d %d %d %d (%d %d)\n",
-               move_area.x, move_area.y,
-               move_area.width, move_area.height,
-               dx, dy);
-#endif
-      cr = cairo_create (area->priv->surface);
-
-      /* Cairo doesn't allow self-copies, so we do this little trick instead:
-       * 1) Clip so the group size is small.
-       * 2) Call push_group() which creates a temporary pixmap as a workaround
-       */
-      gdk_cairo_rectangle (cr, &move_area);
-      cairo_clip (cr);
-      cairo_push_group (cr);
-
-      cairo_set_source_surface (cr, area->priv->surface, dx, dy);
-      gdk_cairo_rectangle (cr, &move_area);
-      cairo_fill (cr);
-
-      cairo_pop_group_to_source (cr);
-      cairo_paint (cr);
-
-      cairo_destroy (cr);
-
-      gtk_widget_queue_draw (GTK_WIDGET (area));
-
-      move_region = cairo_region_create_rectangle (&move_area);
-      cairo_region_translate (move_region, dx, dy);
-      cairo_region_subtract (invalid_region, move_region);
-      cairo_region_destroy (move_region);
-    }
-
-  allocation_to_canvas_region (area, invalid_region);
-
-  foo_scroll_area_invalidate_region (area, invalid_region);
-
-  cairo_region_destroy (invalid_region);
-}
-
-static void
-foo_scrollbar_adjustment_changed (GtkAdjustment *adj,
-                                  FooScrollArea *scroll_area)
-{
-  GtkWidget *widget = GTK_WIDGET (scroll_area);
-  gint dx = 0;
-  gint dy = 0;
-  GdkRectangle old_viewport, new_viewport;
-
-  get_viewport (scroll_area, &old_viewport);
-
-  if (adj == scroll_area->priv->hadj)
-    {
-      /* FIXME: do we treat the offset as int or double, and,
-       * if int, how do we round?
-       */
-      dx = (int)gtk_adjustment_get_value (adj) - scroll_area->priv->x_offset;
-      scroll_area->priv->x_offset = gtk_adjustment_get_value (adj);
-    }
-  else if (adj == scroll_area->priv->vadj)
-    {
-      dy = (int)gtk_adjustment_get_value (adj) - scroll_area->priv->y_offset;
-      scroll_area->priv->y_offset = gtk_adjustment_get_value (adj);
-    }
-  else
-    {
-      g_assert_not_reached ();
-    }
-
-  if (gtk_widget_get_realized (widget))
-    {
-      foo_scroll_area_scroll (scroll_area, -dx, -dy);
-
-      //translate_input_regions (scroll_area, -dx, -dy);
-
-    }
-
-  get_viewport (scroll_area, &new_viewport);
-
-  emit_viewport_changed (scroll_area, &new_viewport, &old_viewport);
-}
-
-static void
-set_one_adjustment (FooScrollArea *scroll_area,
-                    GtkAdjustment *adjustment,
-                    GtkAdjustment **location)
-{
-  g_return_if_fail (location != NULL);
-
-  if (adjustment == *location)
-    return;
-
-  if (!adjustment)
-    adjustment = new_adjustment ();
-
-  g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
-
-  if (*location)
-    {
-      g_signal_handlers_disconnect_by_func (
-                                            *location, foo_scrollbar_adjustment_changed, scroll_area);
-
-      g_object_unref (*location);
-    }
-
-  *location = adjustment;
-
-  g_object_ref_sink (*location);
-
-  g_signal_connect (*location, "value_changed",
-                    G_CALLBACK (foo_scrollbar_adjustment_changed),
-                    scroll_area);
-}
-
-static void
-foo_scroll_area_set_hadjustment (FooScrollArea *scroll_area,
-                                 GtkAdjustment *hadjustment)
-{
-  set_one_adjustment (scroll_area, hadjustment, &scroll_area->priv->hadj);
-
-  set_adjustment_values (scroll_area);
-}
-
-static void
-foo_scroll_area_set_vadjustment (FooScrollArea *scroll_area,
-                                 GtkAdjustment *vadjustment)
-{
-  set_one_adjustment (scroll_area, vadjustment, &scroll_area->priv->vadj);
-
-  set_adjustment_values (scroll_area);
-}
-
-FooScrollArea *
-foo_scroll_area_new (void)
-{
-  return g_object_new (FOO_TYPE_SCROLL_AREA, NULL);
-}
-
-void
-foo_scroll_area_set_min_size (FooScrollArea *scroll_area,
-                              int                  min_width,
-                              int            min_height)
-{
-  scroll_area->priv->min_width = min_width;
-  scroll_area->priv->min_height = min_height;
-
-  /* FIXME: think through invalidation.
-   *
-   * Goals: - no repainting everything on size_allocate(),
-   *        - make sure input boxes are invalidated when
-   *          needed
-   */
-  gtk_widget_queue_resize (GTK_WIDGET (scroll_area));
-}
-
-typedef struct {
-  cairo_t *cr;
-  GtkAllocation allocation;
-} user_to_device_data;
-
-static void
-user_to_device (double *x, double *y,
-                gpointer user_data)
-{
-  gdouble ox, oy;
-  user_to_device_data* data = user_data;
-
-  /* The translations by the user */
-  cairo_user_to_device (data->cr, x, y);
-
-  /* The position of the widget on the window. */
-  *x -= data->allocation.x;
-  *y -= data->allocation.y;
-}
-
-static InputPath *
-make_path (FooScrollArea *area,
-           cairo_t *cr,
-           gboolean is_stroke,
-           FooScrollAreaEventFunc func,
-           gpointer data)
-{
-  user_to_device_data conversion_data;
-
-  InputPath *path = g_new0 (InputPath, 1);
-
-  conversion_data.cr = cr;
-  gtk_widget_get_allocation(GTK_WIDGET (area), &conversion_data.allocation);
-
-  path->is_stroke = is_stroke;
-  path->fill_rule = cairo_get_fill_rule (cr);
-  path->line_width = cairo_get_line_width (cr);
-  path->path = cairo_copy_path (cr);
-  path_foreach_point (path->path, user_to_device, &conversion_data);
-  path->func = func;
-  path->data = data;
-  path->next = area->priv->current_input->paths;
-  area->priv->current_input->paths = path;
-  return path;
-}
-
-/* FIXME: we probably really want a
- *
- *      foo_scroll_area_add_input_from_fill (area, cr, ...);
- * and
- *      foo_scroll_area_add_input_from_stroke (area, cr, ...);
- * as well.
- */
-void
-foo_scroll_area_add_input_from_fill (FooScrollArea           *scroll_area,
-                                     cairo_t                 *cr,
-                                     FooScrollAreaEventFunc   func,
-                                     gpointer                 data)
-{
-  g_return_if_fail (FOO_IS_SCROLL_AREA (scroll_area));
-  g_return_if_fail (cr != NULL);
-  g_return_if_fail (scroll_area->priv->current_input);
-
-  make_path (scroll_area, cr, FALSE, func, data);
-}
-
-void
-foo_scroll_area_add_input_from_stroke (FooScrollArea           *scroll_area,
-                                       cairo_t                  *cr,
-                                       FooScrollAreaEventFunc   func,
-                                       gpointer                 data)
-{
-  g_return_if_fail (FOO_IS_SCROLL_AREA (scroll_area));
-  g_return_if_fail (cr != NULL);
-  g_return_if_fail (scroll_area->priv->current_input);
-
-  make_path (scroll_area, cr, TRUE, func, data);
-}
-
-void
-foo_scroll_area_invalidate (FooScrollArea *scroll_area)
-{
-  GtkAllocation allocation;
-  GtkWidget *widget = GTK_WIDGET (scroll_area);
-
-  gtk_widget_get_allocation (widget, &allocation);
-  foo_scroll_area_invalidate_rect (scroll_area,
-                                   scroll_area->priv->x_offset, scroll_area->priv->y_offset,
-                                   allocation.width,
-                                   allocation.height);
-}
-
-static void
-canvas_to_window (FooScrollArea  *area,
-                  cairo_region_t *region)
-{
-  GtkAllocation allocation;
-  GtkWidget *widget = GTK_WIDGET (area);
-
-  gtk_widget_get_allocation (widget, &allocation);
-  cairo_region_translate (region,
-                          -area->priv->x_offset + allocation.x,
-                          -area->priv->y_offset + allocation.y);
-}
-
-static void
-window_to_canvas (FooScrollArea  *area,
-                  cairo_region_t *region)
-{
-  GtkAllocation allocation;
-  GtkWidget *widget = GTK_WIDGET (area);
-
-  gtk_widget_get_allocation (widget, &allocation);
-  cairo_region_translate (region,
-                          area->priv->x_offset - allocation.x,
-                          area->priv->y_offset - allocation.y);
-}
-
-void
-foo_scroll_area_invalidate_region (FooScrollArea  *area,
-                                   cairo_region_t *region)
-{
-  GtkWidget *widget;
-
-  g_return_if_fail (FOO_IS_SCROLL_AREA (area));
-
-  widget = GTK_WIDGET (area);
-
-  cairo_region_union (area->priv->update_region, region);
-
-  if (gtk_widget_get_realized (widget))
-    {
-      canvas_to_window (area, region);
-
-      gdk_window_invalidate_region (gtk_widget_get_window (widget),
-                                    region, TRUE);
-
-      window_to_canvas (area, region);
-    }
-}
-
-void
-foo_scroll_area_invalidate_rect (FooScrollArea *scroll_area,
-                                 int            x,
-                                 int            y,
-                                 int            width,
-                                 int            height)
-{
-  cairo_rectangle_int_t rect = { x, y, width, height };
-  cairo_region_t *region;
-
-  g_return_if_fail (FOO_IS_SCROLL_AREA (scroll_area));
-
-  region = cairo_region_create_rectangle (&rect);
-
-  foo_scroll_area_invalidate_region (scroll_area, region);
-
-  cairo_region_destroy (region);
-}
-
-void
-foo_scroll_area_begin_grab (FooScrollArea *scroll_area,
-                            FooScrollAreaEventFunc func,
-                            gpointer       input_data)
-{
-  g_return_if_fail (FOO_IS_SCROLL_AREA (scroll_area));
-  g_return_if_fail (!scroll_area->priv->grabbed);
-
-  scroll_area->priv->grabbed = TRUE;
-  scroll_area->priv->grab_func = func;
-  scroll_area->priv->grab_data = input_data;
-
-  /* FIXME: we should probably take a server grab */
-  /* Also, maybe there should be support for setting the grab cursor */
-}
-
-void
-foo_scroll_area_end_grab (FooScrollArea *scroll_area,
-                          FooScrollAreaEvent *event)
-{
-  g_return_if_fail (FOO_IS_SCROLL_AREA (scroll_area));
-
-  scroll_area->priv->grabbed = FALSE;
-  scroll_area->priv->grab_func = NULL;
-  scroll_area->priv->grab_data = NULL;
-
-  if (event != NULL)
-    process_event (scroll_area, FOO_DROP, event->x, event->y);
-}
-
-gboolean
-foo_scroll_area_is_grabbed (FooScrollArea *scroll_area)
-{
-  return scroll_area->priv->grabbed;
-}
-
-void
-foo_scroll_area_set_viewport_pos (FooScrollArea  *scroll_area,
-                                  int             x,
-                                  int             y)
-{
-  g_object_freeze_notify (G_OBJECT (scroll_area->priv->hadj));
-  g_object_freeze_notify (G_OBJECT (scroll_area->priv->vadj));
-  gtk_adjustment_set_value (scroll_area->priv->hadj, x);
-  gtk_adjustment_set_value (scroll_area->priv->vadj, y);
-
-  set_adjustment_values (scroll_area);
-  g_object_thaw_notify (G_OBJECT (scroll_area->priv->hadj));
-  g_object_thaw_notify (G_OBJECT (scroll_area->priv->vadj));
-}
-
-static gboolean
-rect_contains (const GdkRectangle *rect, int x, int y)
-{
-  return (x >= rect->x                &&
-          y >= rect->y                &&
-          x  < rect->x + rect->width  &&
-          y  < rect->y + rect->height);
-}
-
-static void
-stop_scrolling (FooScrollArea *area)
-{
-#if 0
-  g_print ("stop scrolling\n");
-#endif
-  if (area->priv->auto_scroll_info)
-    {
-      g_source_remove (area->priv->auto_scroll_info->timeout_id);
-      g_timer_destroy (area->priv->auto_scroll_info->timer);
-      g_free (area->priv->auto_scroll_info);
-
-      area->priv->auto_scroll_info = NULL;
-    }
-}
-
-static gboolean
-scroll_idle (gpointer data)
-{
-  GdkRectangle viewport, new_viewport;
-  FooScrollArea *area = data;
-  AutoScrollInfo *info = area->priv->auto_scroll_info;
-  int new_x, new_y;
-  double elapsed;
-
-  get_viewport (area, &viewport);
-
-#if 0
-  g_print ("old info: %d %d\n", info->dx, info->dy);
-
-  g_print ("timeout (%d %d)\n", dx, dy);
-#endif
-
-#if 0
-  g_print ("new info %d %d\n", info->dx, info->dy);
-#endif
-
-  elapsed = g_timer_elapsed (info->timer, NULL);
-
-  info->res_x = elapsed * info->dx / 0.2;
-  info->res_y = elapsed * info->dy / 0.2;
-
-#if 0
-  g_print ("%f %f\n", info->res_x, info->res_y);
-#endif
-
-  new_x = viewport.x + info->res_x;
-  new_y = viewport.y + info->res_y;
-
-#if 0
-  g_print ("%f\n", elapsed * (info->dx / 0.2));
-#endif
-
-#if 0
-  g_print ("new_x, new_y\n: %d %d\n", new_x, new_y);
-#endif
-
-  foo_scroll_area_set_viewport_pos (area, new_x, new_y);
-#if 0
-  viewport.x + info->dx,
-    viewport.y + info->dy);
-#endif
-
-get_viewport (area, &new_viewport);
-
-if (viewport.x == new_viewport.x            &&
-    viewport.y == new_viewport.y            &&
-    (info->res_x > 1.0                      ||
-     info->res_y > 1.0                      ||
-     info->res_x < -1.0                     ||
-     info->res_y < -1.0))
-  {
-    stop_scrolling (area);
-
-    /* stop scrolling if it didn't have an effect */
-    return FALSE;
-  }
-
-return TRUE;
-}
-
-static void
-ensure_scrolling (FooScrollArea *area,
-                  int            dx,
-                  int            dy)
-{
-  if (!area->priv->auto_scroll_info)
-    {
-#if 0
-      g_print ("start scrolling\n");
-#endif
-      area->priv->auto_scroll_info = g_new0 (AutoScrollInfo, 1);
-      area->priv->auto_scroll_info->timeout_id =
-        g_idle_add (scroll_idle, area);
-      area->priv->auto_scroll_info->timer = g_timer_new ();
-    }
-
-#if 0
-  g_print ("setting scrolling to %d %d\n", dx, dy);
-#endif
-
-#if 0
-  g_print ("dx, dy: %d %d\n", dx, dy);
-#endif
-
-  area->priv->auto_scroll_info->dx = dx;
-  area->priv->auto_scroll_info->dy = dy;
-}
-
-void
-foo_scroll_area_auto_scroll (FooScrollArea *scroll_area,
-                             FooScrollAreaEvent *event)
-{
-  GdkRectangle viewport;
-
-  get_viewport (scroll_area, &viewport);
-
-  if (rect_contains (&viewport, event->x, event->y))
-    {
-      stop_scrolling (scroll_area);
-    }
-  else
-    {
-      int dx, dy;
-
-      dx = dy = 0;
-
-      if (event->y < viewport.y)
-        {
-          dy = event->y - viewport.y;
-          dy = MIN (dy + 2, 0);
-        }
-      else if (event->y >= viewport.y + viewport.height)
-        {
-          dy = event->y - (viewport.y + viewport.height - 1);
-          dy = MAX (dy - 2, 0);
-        }
-
-      if (event->x < viewport.x)
-        {
-          dx = event->x - viewport.x;
-          dx = MIN (dx + 2, 0);
-        }
-      else if (event->x >= viewport.x + viewport.width)
-        {
-          dx = event->x - (viewport.x + viewport.width - 1);
-          dx = MAX (dx - 2, 0);
-        }
-
-#if 0
-      g_print ("dx, dy: %d %d\n", dx, dy);
-#endif
-
-      ensure_scrolling (scroll_area, dx, dy);
-    }
-}
-
-void
-foo_scroll_area_begin_auto_scroll (FooScrollArea *scroll_area)
-{
-  /* noop  for now */
-}
-
-void
-foo_scroll_area_end_auto_scroll (FooScrollArea *scroll_area)
-{
-  stop_scrolling (scroll_area);
-}
-
diff --git a/panels/display/scrollarea.h b/panels/display/scrollarea.h
deleted file mode 100644
index 9d0fa0e..0000000
--- a/panels/display/scrollarea.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/* Copyright 2006, 2007, 2008, Soren Sandmann <sandmann@daimi.au.dk>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-#include <cairo.h>
-#include <gtk/gtk.h>
-
-#define FOO_TYPE_SCROLL_AREA            (foo_scroll_area_get_type ())
-#define FOO_SCROLL_AREA(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOO_TYPE_SCROLL_AREA, FooScrollArea))
-#define FOO_SCROLL_AREA_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  FOO_TYPE_SCROLL_AREA, FooScrollAreaClass))
-#define FOO_IS_SCROLL_AREA(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOO_TYPE_SCROLL_AREA))
-#define FOO_IS_SCROLL_AREA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  FOO_TYPE_SCROLL_AREA))
-#define FOO_SCROLL_AREA_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  FOO_TYPE_SCROLL_AREA, FooScrollAreaClass))
-
-typedef struct FooScrollArea FooScrollArea;
-typedef struct FooScrollAreaClass FooScrollAreaClass;
-typedef struct FooScrollAreaPrivate FooScrollAreaPrivate;
-typedef struct FooScrollAreaEvent FooScrollAreaEvent;
-
-typedef enum
-  {
-    FOO_BUTTON_PRESS,
-    FOO_BUTTON_RELEASE,
-    FOO_DRAG_HOVER,
-    FOO_DROP,
-    FOO_MOTION
-  } FooScrollAreaEventType;
-
-struct FooScrollAreaEvent
-{
-  FooScrollAreaEventType      type;
-  int                         x;
-  int                         y;
-};
-
-typedef void (* FooScrollAreaEventFunc) (FooScrollArea      *area,
-                                         FooScrollAreaEvent *event,
-                                         gpointer            data);
-
-struct FooScrollArea
-{
-  GtkContainer parent_instance;
-
-  FooScrollAreaPrivate *priv;
-};
-
-struct FooScrollAreaClass
-{
-  GtkContainerClass parent_class;
-
-  void (*set_scroll_adjustments) (FooScrollArea *scroll_area,
-                                  GtkAdjustment *hadjustment,
-                                  GtkAdjustment *vadjustment);
-
-  void (*viewport_changed) (FooScrollArea *scroll_area,
-                            GdkRectangle  *old_viewport,
-                            GdkRectangle  *new_viewport);
-
-  void (*paint) (FooScrollArea  *scroll_area,
-                 cairo_t        *cr,
-                 GdkRectangle   *extents,
-                 cairo_region_t *region);
-};
-
-GType foo_scroll_area_get_type (void);
-
-FooScrollArea *foo_scroll_area_new (void);
-
-/* Set the requisition for the widget. */
-void          foo_scroll_area_set_min_size (FooScrollArea *scroll_area,
-                                            int            min_width,
-                                            int            min_height);
-
-/* Set how much of the canvas can be scrolled into view */
-void          foo_scroll_area_set_size (FooScrollArea          *scroll_area,
-                                        int                     width,
-                                        int                     height);
-void          foo_scroll_area_set_size_fixed_y (FooScrollArea  *scroll_area,
-                                                int             width,
-                                                int             height,
-                                                int             old_y,
-                                                int             new_y);
-void          foo_scroll_area_set_viewport_pos (FooScrollArea  *scroll_area,
-                                                int             x,
-                                                int             y);
-void          foo_scroll_area_get_viewport (FooScrollArea *scroll_area,
-                                            GdkRectangle  *viewport);
-void          foo_scroll_area_add_input_from_stroke (FooScrollArea           *scroll_area,
-                                                     cairo_t                    *cr,
-                                                     FooScrollAreaEventFunc   func,
-                                                     gpointer                 data);
-void          foo_scroll_area_add_input_from_fill (FooScrollArea *scroll_area,
-                                                   cairo_t         *cr,
-                                                   FooScrollAreaEventFunc func,
-                                                   gpointer       data);
-void          foo_scroll_area_invalidate_region (FooScrollArea  *area,
-                                                 cairo_region_t *region);
-void          foo_scroll_area_invalidate (FooScrollArea *scroll_area);
-void          foo_scroll_area_invalidate_rect (FooScrollArea *scroll_area,
-                                               int            x,
-                                               int            y,
-                                               int            width,
-                                               int            height);
-void foo_scroll_area_begin_grab (FooScrollArea *scroll_area,
-                                 FooScrollAreaEventFunc func,
-                                 gpointer       input_data);
-void foo_scroll_area_end_grab (FooScrollArea *scroll_area,
-                               FooScrollAreaEvent *event);
-gboolean foo_scroll_area_is_grabbed (FooScrollArea *scroll_area);
-
-void foo_scroll_area_begin_auto_scroll (FooScrollArea *scroll_area);
-void foo_scroll_area_auto_scroll (FooScrollArea *scroll_area,
-                                  FooScrollAreaEvent *event);
-void foo_scroll_area_end_auto_scroll (FooScrollArea *scroll_area);
diff --git a/panels/display/unity-display-panel.desktop.in.in b/panels/display/unity-display-panel.desktop.in.in
deleted file mode 100644
index c002bca..0000000
--- a/panels/display/unity-display-panel.desktop.in.in
+++ /dev/null
@@ -1,13 +0,0 @@
-[Desktop Entry]
-_Name=Displays
-_Comment=Change resolution and position of monitors and projectors
-Exec=unity-control-center display
-Icon=unity-display-panel
-Terminal=false
-Type=Application
-StartupNotify=true
-Categories=GNOME;GTK;Settings;HardwareSettings;X-Unity-Settings-Panel;
-OnlyShowIn=Unity;
-X-Unity-Settings-Panel=display
-# Translators: those are keywords for the display control-center panel
-_Keywords=Panel;Projector;xrandr;Screen;Resolution;Refresh;
diff --git a/po/POTFILES.in b/po/POTFILES.in
index fba1759..11a0265 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -16,9 +16,6 @@ panels/datetime/datetime-prefs.c
 panels/datetime/datetime-prefs-locations.c
 panels/datetime/unity-datetime-panel.desktop.in.in
 panels/datetime/utils.c
-panels/display/cc-display-panel.c
-[type: gettext/glade]panels/display/display-capplet.ui
-panels/display/unity-display-panel.desktop.in.in
 panels/info/cc-info-panel.c
 panels/info/unity-info-panel.desktop.in.in
 [type: gettext/glade]panels/info/info.ui
@@ -69,5 +66,4 @@ shell/control-center.c
 shell/unity-control-center.desktop.in.in
 shell/unitycc.directory.in
 [type: gettext/glade]shell/shell.ui
-panels/display/cc-rr-labeler.c
 
diff --git a/po/POTFILES.skip b/po/POTFILES.skip
index 238d3d4..7094a39 100644
--- a/po/POTFILES.skip
+++ b/po/POTFILES.skip
@@ -1,7 +1,6 @@
 egg-list-box/egg-flow-box.c
 panels/background/gnome-background-panel.desktop.in
 panels/datetime/gnome-datetime-panel.desktop.in
-panels/display/gnome-display-panel.desktop.in
 panels/info/gnome-info-panel.desktop.in
 panels/mouse/gnome-mouse-panel.desktop.in
 panels/online-accounts/gnome-online-accounts-panel.desktop.in
-- 
1.9.2

